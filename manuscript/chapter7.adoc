= ASP.NET Core webszolgáltatások I.-II.

== Kiegészítő anyagok, segédeszközök

* kapcsolódó GitHub repo: https://github.com/bmeaut/WebApiLab
** elég csak https://github.com/bmeaut/WebApiLab/archive/init2020.zip[zip-ként letölteni], nem kell klónozni 
* https://www.getpostman.com/[Postman] vagy https://www.telerik.com/download/fiddler[Fiddler] HTTP kérések küldéséhez

== Kiinduló projektek beüzemelése

A kiinduló solution két .NET Standard osztálykönyvtárat foglal magába, melyek egy N-rétegű architektúra egy-egy rétegét valósítják meg:

* *WebApiLab.DAL*: lényegében az Entity Framework gyakorlatok anyagát tartalmazza, ez az adatelérési rétegünk.
** entitásdefiníciók
** kontext, modellkonfigurációval, kezdeti adatokkal
** connection string kezelés és SQL naplózás (még) nincs
** migráció (még) nincs
* *WebApiLab.BLL*: ezt szánjuk az üzleti logikai rétegnek. Fő feladata, hogy a DAL-ra építve végrehajtsa az _Interfaces_ mappában definiált műveleteket.
** Interfaces - ez a BLL réteg specifikációja
** Services - ide kerülnek majd az üzleti logikát, ill. az interfészeket megvalósító osztály(ok)
** DTOs - ez majd a fölöttes API rétegnek szükséges, a BLL nem használja
** Exceptions - saját kivétel osztály, egyelőre nincs használva

Adjunk hozzá a solution-höz egy új C# nyelvű web projektet (ASP.NET Core Web Application), a neve legyen _WebApiLab.API_.

A következő dialógusablakban válasszuk ki az _ASP.NET Core 3.1_ opciót és azon belül az API sablont. Más egyéb extrát (HTTPS, Docker, stb.) ne kérjünk. Adjuk hozzá projekt függőségként:

* a _BLL_ projektet
* a _Microsoft.EntityFrameworkCore.Design_ NuGet csomagot
* a _Microsoft.EntityFrameworkCore.Tools_ NuGet csomagot

== Az EF kontext bekötése az ASP.NET Core DI rendszerébe

Mivel az ASP.NET Core projekt DI rendszert is ad, így érdemes a kontextet a DI rendszerbe regisztrálni, hogy a projekten belül a modulok/osztályok függőségként tudják használni. A regisztrálás a `ConfigureServices` függvényben történik (lásd ASP.NET Core bevezető gyakorlatot).

A kontext regisztrálása a `Startup.ConfigureServices` függvénybe:

[source,csharp]
----
services.AddDbContext<NorthwindContext>(o =>
    o.UseSqlServer(Configuration["ConnectionStrings:DefaultConnection"]));
----

Az EF naplózást az ASP.NET Core naplózó rendszere végzi, amit az alapértelmezett `Host` már inicializál, így ezzel kapcsolatban nincs teendőnk. Viszont egy új konstruktorra lesz szükségünk, ami `DbContextOptions<NorthwindContext>`-et vár.

[source,csharp]
----
public NorthwindContext(DbContextOptions<NorthwindContext> options)
    : base(options){}
----

Az Entity Framework gyakorlat alapján hozzunk létre egy új LocalDB adatbázist egy választott névvel, pl. neptun kód, northwind, stb. Az SQL Server Object Explorer-ből a connection string-et lopjuk el. (Jobbklikk az adatbázison → Properties → A Properties ablakból a _Connection String_ értéke).

Az _appsettings.Development.json_-ba vegyük fel a connection string-et. 
[source,javascript]
----
/**/{
/**/  "Logging": {
/**/    "LogLevel": {
/**/      "Default": "Information",
/**/      "Microsoft": "Warning",
/**/      "Microsoft.Hosting.Lifetime": "Information"
/**/    }
      }, //vessző bekerült
      "ConnectionStrings": {
         "DefaultConnection": "<connection string>"
      }
/**/}

----

=== Adatbázis inicializálása Code-First migrációval

Fordítsuk a teljes solution-t, állítsuk be indítandó (startup) projektnek az új Web API projektet. A _Package Manager Console_-t nyissuk meg és ellenőrizzük, állítsuk be Default Project-ként a DAL projektet. Készíttessük el a migrációt és futtassuk is le.

[source,powershell]
----
Add-Migration Init
Update-Database
----

WARNING: Fontos, hogy a fenti parancs két projektet ismerjen: azt, amelyikben a kontext van, ill. a kontextet használó futtatható projektet. A VS Package Manager Console-jában futtatva alapértelmezésben az előbbit a Default Project értéke adja meg, utóbbit az indítandó projekt. Továbbá ezeket a projekteket meg lehet adni https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/powershell#common-parameters[paraméterként] is.

TIP: Itt mutatkozik meg, hogy a migráció lényegében egy teljes alkalmazásindítást jelent a `Startup` osztályon keresztül, inicializálódik a DI konténer, a konfigurációs objektum, stb.

Ellenőrizzük, hogy rendben lefutott-e a migráció, létrejöttek-e az adatbázis objektumok, feltöltődtek-e a táblák.

== EF kontext használata a kontroller rétegben

Bár architektúra szempontból nem a legszebb, a BLL réteget gyakorlatilag mellőzve közvetlenül is használhatjuk az EF entitásokat a kontrollerek megvalósításánál.  A _Controllers_ mappában hozzunk létre egy kontrollert (Add → Controller... → API Controller with actions using Entity Framework). A felbukkanó ablakban válasszuk ki a `Product` entitás osztályt (azaz az Entities névtérbelit), a kontextet és adjunk meg nevet ( `EFProductsController`).

WARNING: Figyeljünk rá, hogy ne a `Dto` névtérből adjuk meg a DTO típust a tényleges entitástípus helyett.

A legenerálódó kontroller már használható is. Állítsuk át a zöld nyíl mellett az indítási konfigurációt a projektnevesre, hogy kestrel induljon és így lássuk a konzolon a naplót. Indítsuk a projektet és próbáljuk például lekérni az összes terméket az **api/efproducts** címről.

TIP: Érdemes a zöld nyíl melletti lenyílóban olyan böngészőt megadni (Chrome, Firefox), ami értelmes formában meg tudja jeleníteni a nyers JSON adatokat.

TIP: Az alapértelmezésben megnyitandó URL útvonalat a projekt tulajdonságok között adhatjuk meg: jobbklikk a projekten Debug lap → Launch Browser. Ide egy a gyökércímhez képesti relatív útvonalrészt kell beírni. (pl. _api/efproducts_)

Figyeljük meg, hogy a controller a konstruktorban igényli meg a DI-tól az EF kontextet, amit a szokásos módon osztályváltozóban tárol el.

== Köztes réteg alkalmazása

A rétegezett architektúra elveit követve gyakori eljárás, hogy a controller nem éri el közvetlenül az EF kontextet, hanem csak egy extra rétegen keresztül. A controller projekt így függetleníthető az EF-től.

Ehhez a megoldáshoz készítsünk külön kontroller változatot. A _Controllers_ mappába hozzunk létre egy kontrollert (Add → Controller... → API Controller with read/write actions) `ProductsController` néven.

A megoldáshoz a _BLL_ projektben már létezik a `ProductService` osztály, aminek szintén függősége az EF kontext és megvalósítja szükséges CRUD műveleteket. Az EF gyakorlaton tanultakra visszautalva mutassuk be a műveletek implementációját. Függőségeknél előnyösebb, ha interfészekre hivatkozunk, mert tesztelésnél az interfész mögötti implementációt általában egyszerűbb cserélni. Szerencsére az `IProductService` interfész is már rendelkezésünkre áll.

A BLL projekt Services mappájába hozzunk létre egy új osztályt `ProductService` néven. Implementálja az IProductService interfészt, a kiinduló implementációt generáltassuk a Visual Studio-val. Konstruktorban várja a függőségként a kontextet. A kontext segítségével implementáljuk normálisan a `GetProducts` függvényt. _Eager Loading_ használatával az egyes termékekhez a kapcsolódó kategóriát és megrendeléseket is adjuk vissza.

[source,csharp]
----
namespace WebApiLab.BLL
{
    public class ProductService : IProductService
    {
        private readonly NorthwindContext _context;
        public ProductService(NorthwindContext context)
        {
            _context = context;
        }       

        public IEnumerable<Product> GetProducts()
        {
            var products = _context.Products
                .Include(p => p.Category)
                .Include(p => p.ProductOrders)
                    .ThenInclude(po => po.Order)
                .ToList();

            return products;
        }
        /*Többi függvény alapimplementációja*/
    }
}
----

Injektáljunk `IProductService`-t a `ProductController`-be.

[source,csharp]
----
private readonly IProductService _productService;
public ProductsController(IProductService productService)
{
    _productService = productService;
}
----

Adjuk meg a DI konténernek, hogy hogyan kell egy `IProductService` típusú függőséget létrehozni. A `ConfigureServices` függvénybe:

[source,csharp]
----
services.AddTransient<IProductService, ProductService>();
----

A függőség injektálás úgy működik, hogy kontrollereket is a központi DI komponens példányosítja, és ilyenkor megvizsgálja a konstruktor paramétereket. Ha a konténerben talál alkalmas beregisztrált osztályt, akkor azt létrehozza és átadja a konstruktornak. Ezt hívjuk konstruktor injektálásnak. Ha a létrehozandó függőségnek is vannak konstruktor paraméterei, akkor azokat is megpróbálja feloldani, így rekurzívan a teljes függőségi objektum hierarchiát le tudja kezelni (ha abban nincs irányított kör).

A regisztráció során több lehetőségünk is van. Egyrészt nem kötelező interfészt megadni egy osztály beregisztrálásához, az osztályt önmagában is be lehet regisztrálni, ilyenkor a konstruktorban is osztályként kell elkérni a függőségeket.

Háromféle példányosítási stratégiával regisztrálhatjuk be az osztályainkat:

* *Transient*: minden egyes injektálás során új példány jön létre
* *Scoped*: HTTP kérésenként egy példány kerül létrehozásra és a kérésen belül mindenkinek ez lesz injektálva
* *Singleton*: mindenkinek ugyanaz a példány kerül átadásra kéréstől függetlenül

Írjunk új `Get()` változatot az eredeti helyett a `ProductsController`-be az `IProductService` függőséget felhasználva:

[source,csharp]
----
[HttpGet]
public IEnumerable<Product> Get()
{
    return _productService.GetProducts();
}
----

Próbáljuk ki (`api/products`). A konzolon láthatóan hibát kapunk, mert a `ProductService` lekérdező függvénye eager loading-gal (`Include`) navigációs property-ket is kitölt, így könnyen hivatkozási kör jön létre, amit a JSON sorosító alapértelmezésben kivétellel jutalmaz. A sorosítást a keretrendszer végzi, a kontrollerfüggvény visszatérési értékét sorosítja a HTTP tartalomegyeztetési szabályok szerint. Böngésző kliens esetén alapesetben JSON formátum lesz a befutó. Persze a sorosítás ennél közvetlenebbül is https://docs.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting[konfigurálható], ha szükséges. Sajnos az ASP.NET Core 3 új, alapértelmezett sorosítója még konfigurálással sem támogatja a körkörös hivatkozások feloldását.

TIP: A korábbi verziókban használt JSON sorosítót lehetett konfigurálni, hogy oldja fel a körkörös hivatkozást. Ha mindenképp erre van szükségünk, akkor le kell cserélni az alapértelmezett sorosítót a https://docs.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting?view=aspnetcore-3.1#add-newtonsoftjson-based-json-format-support[korábbira].

== DTO osztályok

Láthattuk, hogy az entitástípusok közvetlen sorosítása gyakran nem működik. A modell kifejezetten az EF számára lett megalkotva, illetve hogy a lekérdező műveleteket minél kényelmesebben végezhessük. A kliensoldal számára érdemes külön modellt megalkotni, egy ún. DTO (_Data Transfer Object_) modellt, ami a kliensoldal igényeit veszi figyelembe: *pontosan* annyi adatot és **olyan szerkezetben** tartalmaz, amire a kliensnek szüksége van.

A _BLL_ projektben jelenleg egy nagyon egyszerű DTO modell található a _DTOs_ mappában:

* nincs benne minden navigációs property, pl. `Category.Products`
* nincs benne a kapcsolótáblát reprezentáló entitás
* a termékből közvetlenül elérhetők a megrendelések

A különféle modellek közötti leképezésnél jól jönnek az ún. object mapper-ek, melyek segítenek elkerülni a leképezésnél nagyon gyakori repetitív kódokat, mint amilyen az `x.Prop=y.Prop` jellegű property érték másolgatás.

Adjuk hozzá a projekthez az _AutoMapper.Extensions.Microsoft.DependencyInjection_ csomagot. A `ConfigureServices`-ben adjuk hozzá és konfiguráljuk a leképezési szolgáltatást.

[source,csharp]
----
services.AddAutoMapper(typeof(Startup));
----

Az AutoMapper konfigurációját profilokba szervezve adhatjuk meg. Adjunk hozzá a projekthez egy új mappát AutoMapper néven és abba egy új osztályt `WebApiProfile` néven.

[source,csharp]
----
namespace WebApiLab.API
{
    public class WebApiProfile : Profile
    {
        public WebApiProfile()
        {
            CreateMap<Entities.Product, DTO.Product>()
                .ForMember(dto => dto.Orders, opt => opt.Ignore())
                .AfterMap((p, dto, ctx) =>
                    dto.Orders = p.ProductOrders.Select(po =>
                    ctx.Mapper.Map<DTO.Order>(po.Order)).ToList())
                .ReverseMap();
            CreateMap<Entities.Order, DTO.Order>().ReverseMap();
            CreateMap<Entities.Category, DTO.Category>().ReverseMap();
        }
    }
}
----

TIP: Az AutoMapper az `AddAutoMapper` paramétereként megadott típust definiáló szerelvényben fogja a profilt keresni.

Injektáltassuk be a leképzőt reprezentáló `IMapper` típusú objektumot a kontrollerbe.

[source,csharp]
----
/**/private readonly IProductService _productService;
    private readonly IMapper _mapper;
/**/public ProductsController(IProductService productService
                         ,IMapper mapper
/**/)
/**/{
/**/    _productService = productService;
        _mapper = mapper;
/**/}
----

Az entitásokra mutató névteret cseréljük ki a DTO-kra mutató névtérre:

[source,csharp]
----
//using WebApiLab.Entities;
using WebApiLab.API.DTO;
----

Írjuk át a REST műveleteket a leképzőt alkalmazva (a Delete-en nem kell változtatni):

[source,csharp]
----
/**/[HttpGet]
/**/public IEnumerable<Product> Get()
/**/{
        return _mapper.Map<IEnumerable<Product>>(_productService.GetProducts());
/**/}
----

Próbáljuk ismét meghívni böngészőből a fenti műveletet - most már működnie kell.

TIP: A többrétegű architektúránál elméletben minden rétegnek külön objektummodellje kellene, hogy legyen DAL: EF entitások, BLL: domain objektumok, Kontroller: DTO-k, viszont ha a domain objektumok nem visznek plusz funkciót a rendszerbe, el szoktuk hagyni.

TIP: A DTO leképezést más rétegben is végezhetnénk. Egyes megközelítések szerint az adatátviteli réteg feladata lenne, esetünkben a kontrolleré.

TIP: Ha a DTO mappelést az üzleti szolgáltatás rétegben szeretnénk végezni, akkor akár az SQL szintjén is konvertálhatjuk az http://docs.automapper.org/en/stable/Queryable-Extensions.html[AutoMapper] vagy a https://github.com/yugabe/QueryMutator[QueryMutator] NuGet csomag segítségével. Ilyenkor csak a DTO képzéshez szükséges adatokat kérdezzük le az adatbázisból.

== BLL funkciók implementációja

=== Egy elem lekérdezése

Ugyanúgy kérdezzük le, mint a `GetProducts`-ban, csak a végére beteszünk egy szűrést (`SingleOrDefault`), ami `null`-t ad vissza, ha nem volt az adott azonosítóval termék. Ha nem található a termék, akkor ebben a rétegben kivételt dobunk.

[source,csharp]
----
/**/public Product GetProduct(int productId)
/**/{
        return _context.Products
           .Include(p => p.Category)
           .Include(p => p.ProductOrders)
               .ThenInclude(po => po.Order)
           .SingleOrDefault(p => p.Id == productId) 
            ?? throw new EntityNotFoundException("Nem található a termék");
/**/}
----

=== Beszúrás

Ez nagyon hasonló az EF gyakorlaton látottakhoz, csak itt nem kell legyártanunk az új `Product` példányt, paraméterként kapjuk. A visszatérési értékben a kulcs értéke már ki lesz töltve (adatbázis osztja ki a kulcsot).

[source,csharp]
----
public Product InsertProduct(Product newProduct)
{
    _context.Products.Add(newProduct);
    _context.SaveChanges();
    return newProduct;
}
----

=== Módosítás

Konvenció szerint külön paraméterként szokták átadni a módosítandó elem azonosítóját és az új értékeket összefogó példányt. Első lépésben összeállítunk egy olyan példányt, mint amilyet az adatbázisból kérdeztünk volna le - viszont ez a példány nem lesz a kontext látókörében. Az `Attach` függvény hasonló az `Add`-hoz, hozzáadja a kontext nyilvántartásához a példányt, de az `Attach` nem jelöli meg a státuszt, marad változatlan. Explicit megjelöljük változottként, a változást végül a SaveChanges érvényesíti.

[source,csharp]
----
public void UpdateProduct(int productId, Product updatedProduct)
{
    updatedProduct.Id = productId;
    var entry = _context.Attach(updatedProduct);
    entry.State = EntityState.Modified;
    _context.SaveChanges();
}
----

=== Törlés

Egy trükkel elkerülhetjük, hogy le kelljen kérdezni a törlendő terméket. Az azonosító alapján előállítunk memóriában egy példányt a megfelelő kulccsal, majd `Remove` függvénnyel hozzáadjuk a kontexthez. A `Remove` törlendőnek jelöli a példányt.

[source,csharp]
----
public void DeleteProduct(int productId)
{
    _context.Products.Remove(new Product { Id = productId });
    _context.SaveChanges();
}
----

== REST konvenciók alkalmazása

A REST megközelítés nem csak átviteli közegnek tekinti a HTTP-t, hanem a protokoll részeit felhasználja, hogy kiegészítő információkat vigyen át. Emiatt előnyös lenne, ha nagyobb ellenőrzésünk lenne a HTTP válasz felett - szerencsére az ASP.NET Core biztosítja ehhez a megfelelő API-kat.

Egyik legegyszerűbb ilyen irányelv, hogy a lekérdezések eredményeként, ha megtaláltuk és visszaadtuk a kért adatokat, akkor *200 (OK)* HTTP válaszkódot adjunk.

TIP: A HTTP kérést érintő irányelvekről egy jó összefoglaló elérhető https://www.restapitutorial.com/lessons/httpmethods.html[itt].

Az eddig megírt `Get()` függvényünk most is *200 (OK)*-ot ad, ezt le is ellenőrizhetjük a böngészőnk hálózati monitorozó eszközében.

TIP: A HTTP kommunikáció megfigyelésére használhatjuk a böngészők beépített eszközeit, minta amilyen a https://developer.mozilla.org/en-US/docs/Tools[Firefox Developer Tools], illetve https://developers.google.com/web/tools/chrome-devtools/[Chrome DevTools]. Általában az kbd:[F12] billentyűvel aktiválhatók. Emellett, ha egy teljesértékű HTTP kliensre van szükségünk, amivel például könnyen tudunk nem csak GET kéréseket küldeni, akkor a https://www.getpostman.com/[Postman] és a https://www.telerik.com/download/fiddler[Fiddler] külön telepítendő eszközök ajánlhatók. A Fiddler, mint proxy megoldás, egy Windows gépen folyó HTTP kommunikáció megfigyelésére is alkalmas.

Első körben a két lekérdező függvényt írjuk át úgy, hogy a HTTP válaszkódokat explicit megadjuk. A jelenlegi legmodernebb mód ehhez az `AsyncResult<>` használata. Elég `T`-t visszaadnunk a függvényben, automatikusan `AsyncResult<T>` típussá konvertálódik. Tehát elvileg írhatnánk ezt:

[source,csharp]
----
//NEM FORDUL!
/**/[HttpGet]
    public ActionResult<IEnumerable<Product>> Get() 
        //ActionResult<T> visszatérési érték
/**/{
/**/    return _mapper.Map<IEnumerable<Product>>(_productService.GetProducts());
/**/}
----

Azonban ez nem fordul, mert interfész típus esetén nem működik a konverzió. Konkrét típust, pl. egy listát kell megadnunk.

[source,csharp]
----
/**/[HttpGet]
/**/public ActionResult<IEnumerable<Product>> Get()
/**/{
        return _mapper.Map<List<Product>>(_productService.GetProducts()); 
            //IEnumerable helyett List
/**/}
----

Írjuk meg ugyanígy a másik `Get` függvényt is:

[source,csharp]
----
/**/[HttpGet("{id}", Name = "Get")]
    public ActionResult<Product> Get(int id)
        //ActionResult<T> visszatérési érték
/**/{
        return _mapper.Map<Product>(_productService.GetProduct(id));
/**/}
----

Próbáljuk ki mindkét kontroller függvényt (_api/products_, _api/products/1_), ellenőrizzük a státuszkódokat is.

Ami fura, hogy még mindig nem állítottunk explicit státuszkódokat. A logikánk most még nagyon egyszerű, csak a hibamentes ágat kezeltük, így eddig az `ActionResult` alapértelmezései megoldották, hogy *200 (OK)*-ot kapjunk.

Most viszont következzen egy létrehozó művelet:

[source,csharp]
----
/**/[HttpPost]
    public ActionResult<Product> Post([FromBody] Product product)
        //ActionResult<T> visszatérési érték + Product paraméter
/**/{
        var created = _productService
            .InsertProduct(_mapper.Map<Entities.Product>(product));
        return CreatedAtAction(
                    nameof(Get),
                    new { id = created.Id },
                    _mapper.Map<Product>(created)
        );
/**/}
----

Itt már látszik az `ActionResult` haszna. A konvenciónak megfelelően 201-es kódot akarunk visszaadni. Ehhez a `ControllerBase` ősosztály biztosít segédfüggvényt. A segédfüggvény olyan `ActionResult` leszármazottat ad vissza, ami 201-es kódot szolgáltat a kliensnek. Másik konvenció, hogy a _Location_ HTTP fejlécben legyen egy URL az új termék lekérdező műveletének meghívásához. Ezt az URL-t rakjuk össze a `CreatedAtAction` paraméterei révén.

Próbáljuk ki a műveletet Fiddlerben vagy https://learning.postman.com/docs/postman/sending-api-requests/requests/[Postmanben]! Egy `Product`-ot kell felküldenünk. Egy példa érték:

[source,javascript]
----
{
    "Name" : "Pálinka",
    "UnitPrice" : 4000,
    "ShipmentRegion" : 1,
    "CategoryId" : 1
}
----

Ne felejtsük el a _Content-Type_ fejlécet  application/json-re állítani! Figyeljük meg a kapott választ. A válaszból másoljuk ki a _Location_ fejlécből az URL-t és hívjuk meg böngészőből.

image::images/aspnetcorerest-fiddlerpost.png[Fiddler - POST küldése]

A módosító, törlő műveleteknél a konvenció megengedi, hogy üres törzsű (body) választ adjunk, ilyenkor a válaszkód *204 (No Content)*. Ilyesfajta válasz előállításához is van segédfüggvény, illetve elég csak az `IActionResult` interfészt megadni visszatérési típusnak:

[source,csharp]
----
/**/[HttpPut("{id}")]
    public IActionResult Put(int id, [FromBody] Product product)
         //ActionResult<T> visszatérési érték + Product paraméter
/**/{
        _productService.
                UpdateProduct(id, _mapper.Map<Entities.Product>(product));
        return NoContent();
/**/}

/**/[HttpDelete("{id}")]
public IActionResult Delete(int id)
     //ActionResult<T> visszatérési érték
/**/{
        _productService.DeleteProduct(id);
        return NoContent();
/**/}
----

TIP: PUT mellett a módosításhoz használatos a PATCH is. A PUT konvenció szerint teljes, míg a PATCH részleges felülírásnál használatos. PATCH esetén általában valamilyen patch formátumú adatot küld a kliens, pl. https://tools.ietf.org/html/rfc6902[RFC 6902 - JSON Patch]. A JSON Patch formátumot jelenleg csak a korábbi sorosító (Newtonsoft.Json) https://docs.microsoft.com/en-us/aspnet/core/web-api/jsonpatch?view=aspnetcore-3.1[támogatja].

Próbáljuk kitörölni az újonnan felvett terméket Fiddler/Postman-ből (_DELETE_ igés kérés az `api/products/<új id>` címre, üres törzzsel). Sikerülnie kell, mert még nincs rá idegen kulcs hivatkozás.

== Hibakezelés

Eddig főleg csak a hibamentes ágakat (happy path) néztük. A REST konvenciók rendelkeznek arról is, hogy bizonyos hibahelyezetekben milyen https://httpstatuses.com[HTTP választ] illik adni, például ha a kérésben hivatkozott azonosító nem létezik - 404-es hiba a bevett eljárás. Státuszkódok szempontjából a korábban idézett oldal ad segítséget, a válasz törzsében a hibaüzenet szerkezete tekintetében az https://tools.ietf.org/html/rfc7807[RFC 7807] ad iránymutatást az ún. _Problem Details_ típusú válaszok bevezetésével. Az ASP.NET Core 2.1-es verzió óta támogatja a Problem Details válaszokat, és általában automatikusan ilyen válaszokat küld.

=== 400 Bad Request

Kezdjük a kliens által küldött nem helyes adatokkal. Ez a hibakód nem összekeverendő a 415-tel, ahol az adat formátuma nem megfelelő (XML vagy JSON): ezt általában nem kell kézzel lekezeljük, mivel ezt az ASP.NET megteszi helyettünk. 400-zal olyan hibákat szoktunk lekezelni, ahol a küldött adat formátuma megfelelő, de valamilyen saját validációs logikának nem felel meg a kapott objektum pl.: egységár nem lehet negatív stb.

Itt használjuk fel a .NET ún. https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-3.1#built-in-attributes[_Data Annotation_ attribútumait], amiket a DTO-kon érvényesíthetünk, és az ASP.NET Core figyelembe vesz a művelet végrehajtása során. Vegyük fel a `Product` DTO osztályban néhány megkötést attribútumok formájában.

[source,csharp]
----
    [Required(ErrorMessage = "Product name is required.", AllowEmptyStrings = false)]
/**/public string Name { get; set; }

    [Range(1, int.MaxValue, ErrorMessage = "Unit price must be higher than 0.")]
/**/public int UnitPrice { get; set; }
----

Próbáljuk ki egy *POST /api/Products* művelet meghívásával. Paraméterként kiindulhatunk a felület által adott minta JSON-ból, csak töröljük ki a navigációs property-ket és sértsük meg valamelyik (vagy mindkét) fenti szabályt. Egy példa törzs:

[source,javascript]
----
{
    "Name" : "",
    "UnitPrice" : 0,
    "ShipmentRegion" : 1,
    "CategoryId" : 1
}
----

A válasz 400-as kód és valami hasonló, RFC 7807-nek megfelelő törzs lesz:

[source,javascript]
----
{
    "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
    "title": "One or more validation errors occurred.",
    "status": 400,
    "traceId": "|2f35d378-4420cbafb80aec04.",
    "errors": {
        "Name": [
            "Product name is required."
        ],
        "UnitPrice": [
            "Unit price must be higher than 0."
        ]
    }
}
----

=== 404 Not Found - kontroller szinten

Konvenció szerint 404-es hibát kellene adnunk, ha a keresett azonosítóval nem található erőforrás - esetünkben termék. Jelenleg a `ProductService` `EntityNotFoundException`-t dob, és amennyiben Development módban futtatjuk az alkalmazást, a cifra hibaoldal jelenik meg, amit a _DeveloperExceptionPage_ middleware generál. Ha kivesszük a middleware-t (vagy nem Development módban indítjuk, de ekkor gondoskodnunk kell connection string-ről, ami eddig csak a Development konfigurációban volt beállítva), akkor 500-as hibát kapunk vissza.

WARNING: A kezeletlen kivételek általában 500-as hibakód formájában kerülnek vissza a kliensre, mindenfajta egyéb információ nélkül (üres oldalként jelenik meg). Ez a jobbik eset, ahhoz képest, ha a teljes kivételszöveg és stack trace is visszakerülne. Az átlagos felhasználók nem tudják értelmezni, viszont a támadó szándékúaknak értékes információt jelenthet, így ajánlott elkerülni, hogy a kivétel ilyen módon kijusson. Ez az elkerülés az úgynevezett _exception shielding_ technika, és az ASP.NET Core alapértelmezetten alkalmazza.

Legegyszerűbb módszer a kontroller műveletben érvényesíteni a konvenciót:

[source,csharp]
----
/**/[HttpGet("{id}", Name = "Get")]
/**/public ActionResult<Product> Get(int id)
/**/{
        try
        {
/**/        return _mapper.Map<Product>(_productService.GetProduct(id));
        }
        catch (EntityNotFoundException)
        {
            return NotFound();
        }    
/**/}
----

TIP: Alternatív megoldás, hogy a `ProductService` egy `null` értékkel jelezné, hogy nincs találat. Ezesetben a fenti kódban a `null` értékre kellene vizsgálni, pl. `if` szerkezettel.

Próbáljuk ki egy, hogy 404-es státuszkódot és annak megfelelő _problem details_-t kapunk-e, ha egy nem létező termékazonosítóval hívjuk a fenti műveletet.

Ha saját _problem details_-t szeretnénk a 404-es kód mellé, akkor kézzel összerakhatjuk és visszaküldhetjük.

[source,csharp]
----
/**/catch (EntityNotFoundException)
/**/{
        ProblemDetails details= new ProblemDetails
        {
            Title = "Invalid ID",
            Status = StatusCodes.Status404NotFound,
            Detail = $"No product with ID {id}"
        };
        return NotFound(details); //ProblemDetails átadása
/**/}
----

Így is próbáljuk ki. Az általunk megadott üzenetet kell visszakapjuk.

=== 404 Not Found - globális kivétel leképezéssel

A rendhagyó válaszok előállításánál előnyös lehet, ha az alacsonyabb rétegekből specifikus kivételeket dobunk, mert ezeket egy központi helyen szisztematikusan átalakíthatjuk konvenciónak megfelelő HTTP válaszokká. Ez a képesség egyelőre még nem érhető el beépítetten, ezért egy https://github.com/khellang/Middleware[közösségi fejlesztésű NuGet csomagot] használunk fel.

Telepítsük fel a _Hellang.Middleware.ProblemDetails_ csomagot az API projektbe. Megtehetjük a szokásos módon, de akár a Package Manager Console-ból is a következő paranccsal (az API projekt legyen megadva, mint _Default Project_):

[source,powershell]
----
Install-Package Hellang.Middleware.ProblemDetails
----

Szokás szerint konfiguráljuk a `Startup.ConfigureServices`-ben. Sose adjuk vissza a kivétel részleteit (szigorú _exception shielding_), illetve a saját kivételtípusunkat képezzük le 404-es hibára.

[source,csharp]
----
services.AddProblemDetails(options =>
{
    options.IncludeExceptionDetails = (ctx,ex) => false;
    options.MapToStatusCode<EntityNotFoundException>(StatusCodes.Status404NotFound);
});

----

Illesszük a pipeline-ba az eddigi hibakezelő MW helyére:

[source,csharp]
----
/**/public void Configure(/*...*/)
/**/{
        //if (env.IsDevelopment())
        //{
        //    app.UseDeveloperExceptionPage();
        //}
        app.UseProblemDetails();
/**/    
/**/    //további MW-k
/**/}
----

Térjünk vissza a korábbi, nem kivétel-elkapós változatra, az előzőt kommentezzük ki:

[source,csharp]
----
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    return _mapper.Map<Product>(_productService.GetProduct(id));
}
----

Próbáljuk ki: hasonlóan kell működjön, mint a kontroller szintű változat, de ez általánosabb, bármely műveletből `EntityNotFoundException` érkezik, azt kezeli, nem kell minden műveletben megírni a kezelő logikát.

=== 500 Internal Server Error

Próbáljunk kitörölni egy nem létező terméket **DELETE api/products/<nem létező id>** kéréssel. Az újonnan beállított MW a nem kezelt kivétel esetén is egy alapszintű Problem Details választ állít elő 500-as kóddal.

=== Azonosítók ellenőrzése

Készítsük fel a módosító és törlő műveleteket is a nem létező azonosítók konvenció szerinti kezelésére.

[source,csharp]
----
/**/public void UpdateProduct(int productId, Product updatedProduct)
/**/{
/**/    updatedProduct.Id = productId;
/**/    var entry = _context.Attach(updatedProduct);
/**/    entry.State = EntityState.Modified;
        try
        {
/**/         _context.SaveChanges();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (_context.Products.SingleOrDefault(p => p.Id == productId) == null)
                throw new EntityNotFoundException("Nem található a termék");
            else throw;
        }
/**/}

/**/public void DeleteProduct(int productId)
/**/{
/**/    _context.Products.Remove(new Product { Id = productId });          
        try
        {
/**/        _context.SaveChanges();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (_context.Products.SingleOrDefault(p => p.Id == productId) == null)
                throw new EntityNotFoundException("Nem található a termék");
            else throw;
        }
/**/}
----

Ez egy optimista megközelítés: feltételezzük, hogy helyes azonosítót kapunk. Ha kivételes esetben mégsem, akkor az UPDATE/INSERT utasítás nem a megfelelő számú sort módosítja és `DbUpdateConcurrencyException`-t kapunk. Ekkor vizsgáljuk csak meg, hogy az azonosító helyes-e.

=== Saját hibaüzenet

Módosítsuk a hibakezelő MW konfigurációját a `Startup.ConfigureServices` függvényben, hogy a kivétel szövege bekerüljön a válaszba. Ez akkor lehet hasznos, ha a felhasználónak kiírandó hibaüzenetet is vissza akarjuk küldeni (másik lehetőség, hogy a kliens állítja elő, pl. a státuszkód alapján).

[source,csharp]
----
/**/services.AddProblemDetails(options =>
/**/{
/**/    options.IncludeExceptionDetails = (ctx, ex) => false;
        options.Map<EntityNotFoundException>(
            (ctx, ex) =>
            {
                var pd=StatusCodeProblemDetails.Create(StatusCodes.Status404NotFound);
                pd.Title = ex.Message;
                return pd;
            }
        );
/**/});
----

WARNING: Az _exception shielding_ elv miatt csak olyan kivételeknél alkalmazzuk, ahol a felhasználók számára hasznos, de nem technikai jellegű információt tartalmaz a kivétel szövege.

== Aszinkron műveletek

Aszinkron műveletek alkalmazásával hatékonyságjavulást érhetünk el: nem feltétlenül az egyes műveletink lesznek gyorsabbak, hanem időegység alatt több műveletet tudunk kiszolgálni. Ennek oka, hogy az `await`-nél (például egy adatbázis művelet elküldésekor) a várakozási idejére történő kiugrásnál, ha vissza tudunk ugrálni egészen az ASP.NET engine szintjéig, akkor a végrehajtó környezet a kiszolgáló szálat a várakozás idejére más kérés kiszolgálására felhasználhatja.

TIP: Ökölszabály, hogy ha elköteleztük magunkat az aszinkronitás mellett, akkor ha megoldható, az aszinkronitást vezessük végig a kontrollertől az adatbázis művelet végrehajtásáig minden rétegben. Ha egy API-nak van _TAP_ jellegű változata, akkor azt részesítsük előnyben (pl. `SaveChanges` helyett `SaveChangesAsync`). Ha aszinkronból szinkronba váltunk, csökkentjük a hatékonyságot, rosszabb esetben deadlock-ot is https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html[előidézhetünk].

Vezessük végig az aszinkronitást egy művelet teljes végrehajtásán:

[source,csharp]
----
/**/public interface IProductService
/**/{
        //void UpdateProduct(int productId, Product updatedProduct);
        Task UpdateProductAsync(int productId, Product updatedProduct);
/**/    //többi fv.
/**/}

    public async Task UpdateProductAsync(int productId, Product updatedProduct)
/**/{
/**/    updatedProduct.Id = productId;
/**/    var entry = _context.Attach(updatedProduct);
/**/    entry.State = EntityState.Modified;
/**/
/**/    try
/**/    {
            await _context.SaveChangesAsync(); //async változat hívása
/**/    }
/**/    catch (DbUpdateConcurrencyException)
/**/    {
           if ((await _context.Products
                        .SingleOrDefaultAsync(p => p.Id == productId)) == null)
            //async változat hívása
/**/               throw new EntityNotFoundException("Nem található a termék");
/**/        else throw;
/**/    }
/**/}


    public async Task<IActionResult> PutAsync(int id, [FromBody] Product product)
/**/{
/**/  await _productService.
        UpdateProductAsync(id, _mapper.Map<Entities.Product>(product));
           //async változat hívása 
/**/  return NoContent();
/**/}
----

Próbáljuk ki, például küldjünk PUT-ot az `api/products/1` címre, állítsuk be a _Content-Type: application/json_ fejlécet és a POST-nál használt JSON-t küldjük a törzsben. Ezzel az 1-es `id`-jű termék adatait fogjuk felülírni.

TIP: az ASP.NET Core a routing során automatikusan levágja az Async végződést a műveletet megvalósító függvény (`PutAsync` végéről).

== Végállapot

A többi műveletet aszinkronizálva ez a végállapot (elérhető a kapcsolódó GitHun repo https://github.com/bmeaut/WebApiLab/tree/v3.1[v3.1-es ágán] is):

[source,csharp]
----
public interface IProductService
{
    Task<Product> GetProductAsync(int productId);
    Task<IEnumerable<Product>> GetProductsAsync();
    Task<Product> InsertProductAsync(Product newProduct);
    Task UpdateProductAsync(int productId, Product updatedProduct);
    Task DeleteProductAsync(int productId);
}

public class ProductService : IProductService
{
    private readonly NorthwindContext _context;

    public ProductService(NorthwindContext context)
    {
        _context = context;
    }

    public async Task DeleteProductAsync(int productId)
    {
        _context.Products.Remove(new Product { Id = productId });          
        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if ((await _context.Products
                .SingleOrDefaultAsync(p=>p.Id == productId)) == null)
                throw new EntityNotFoundException("Nem található a termék");
            else throw;
        }
    }

    public async Task<Product> GetProductAsync(int productId)
    {
        return (await _context.Products
           .Include(p => p.Category)
           .Include(p => p.ProductOrders)
               .ThenInclude(po => po.Order)
           .SingleOrDefaultAsync(p => p.Id == productId))
           ?? throw new EntityNotFoundException("Nem található a termék");
    }

    public async Task<IEnumerable<Product>> GetProductsAsync()
    {
        var products = await _context.Products
            .Include(p => p.Category)
            .Include(p => p.ProductOrders)
                .ThenInclude(po => po.Order)
            .ToListAsync();

        return products;
    }

    public async Task<Product> InsertProductAsync(Product newProduct)
    {
        _context.Products.Add(newProduct);
        await _context.SaveChangesAsync();
        return newProduct;
    }    

    public async Task UpdateProductAsync(int productId, Product updatedProduct)
    {
        updatedProduct.Id = productId;
        var entry = _context.Attach(updatedProduct);
        entry.State = EntityState.Modified;
        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if ((await _context.Products
                    .SingleOrDefaultAsync(p => p.Id == productId)) == null)
                throw new EntityNotFoundException("Nem található a termék");
            else throw;
        }
    }
}

[Route("api/[controller]")]
[ApiController]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;
    private readonly IMapper _mapper;
    public ProductsController(IProductService productService, IMapper mapper)
    {
        _productService = productService;
        _mapper = mapper;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> GetAsync()
    {
        return _mapper.Map<List<Product>>(await _productService.GetProductsAsync());
    }

    [HttpGet("{id}", Name = "Get")]
    public async Task<ActionResult<Product>> Get(int id)
    {
        return _mapper.Map<Product>(await _productService.GetProductAsync(id));
    }

    [HttpPost]
    public async Task<ActionResult<Product>> Post([FromBody] Product product)
    {
        var created = await _productService
            .InsertProductAsync(_mapper.Map<Entities.Product>(product));
        return CreatedAtAction(
                    nameof(Get),
                    new { id = created.Id },
                    _mapper.Map<Product>(created)
        );
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Put(int id, [FromBody] Product product)
    {
        await _productService
            .UpdateProductAsync(id, _mapper.Map<Entities.Product>(product));
        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete(int id)
    {
        await _productService.DeleteProductAsync(id);
        return NoContent();
    }
}
----