# ASP.NET Core alapok

## Projekt létrehozása

Ezen a laboron nem a beépített API projektsablont fogjuk felhasználni, hanem egy üres ASP.NET Core projektből próbáljuk felépíteni és megérteni azt a funkcionalitást, amit egyébként az előre elkészített VS projektsablonok adnának készen a kezünkbe.

### Generálás

Hozzunk létre a Visual Studioban egy új projektet: (C# → Web → ASP.NET Core Web Application (.NET Core)), a neve legyen *HelloAspNetCore*.
A következő dialógusablakban válasszuk ki az *ASP.NET Core 2.2* opciót és azon belül a Empty sablont. Most szándékosan nem a *Web Api* vagy a *Web Application* opciót választottuk, mivel a labor célja egy általános ASP.NET Core alkalmazás működésének megismerése, amit most saját kezűleg fogunk felépíteni.

![ASP.NET Core templates](images/aspnetcore1-choosetemplate.png)

### Eredmény

Nézzük meg milyen projekt generálódott:

- **.csproj**: (Projekten jobb gomb, edit .csproj) a projekt fordításához szükséges beállításokat tartalmazza. Előző verziókhoz képest itt erősen építenek az alapértelmezett értékekre, hogy minél karcsúbbra tudják fogni ezt az állományt.
  - **SDK**: projekt típusa (Microsoft.NET.Sdk.Web), tooling funkcióit szabályozza
  - **TargetFramework**: netcoreapp2.x (.NET Core 2.x)
  - **PackageReference**: függőségek, NuGet csomagok
- **Properties**: duplakattra előjön a klasszikus projekt beállító felület
  - **launchSettings.json:** Properties node-ot lenyitva találjuk meg a különböző indítási konfigurációkhoz tartozó beállításokat. Fontos, hogy ezek a beállítások csak Visual Studióból indítva jutnak érvényre.
- **Dependencies**: SDK és NuGet csomagfüggőségek kezelése
  - Az AspNetCore.App csomag került be, ami egy metacsomag, összefog kb. minden MS fejlesztésű, ASP.NET Core alapcsomagot, a fordításnál képes a nem használt csomagokat kiszűrni.
- **appsettings.json**: futásidejű beállítások helye

#### Program.cs

Az előző ASP.NET verzióval ellentétben, itt már az ASP.NET Core alkalmazások a születésüktől fogva klasszikus konzolos alkalmazásként is indíthatók, ekkor az alkalmazás alapértelmezett belépési pontja a `Program` osztály statikus `Main` metódusa. Itt a következő lépéseket végzi el a kód:

- a hosztolási környezetet és az alkalmazás szerkezetét felállító builder objektum összeállíttatása (`CreateWebHostBuilder` függvényhívás)
- a builder objektum alapján a hosztolási környezet és az alkalmazás szerkezetének felállítása (`Build` függvényhívás)
- a felállított szerkezet futtatása (`Run` függvényhívás)

Az igazán munkás feladat a builder megalkotása lenne, igen sok mindent lehetne benne konfigurálni, ez a kódban a `CreateWebHostBuilder`-ben történik. Szerencsére meghívhatjuk a `CreateDefaultBuilder` gyártófüggvényt, ami egy szokványos (főleg hosztinggal kapcsolatos) beállításokat tartalmazó buildert állít elő. Az alkalmazás szerkezetét pedig a `Startup` osztállyal írjuk le. A `Startup `osztályra nincsenek erős megkötések, nem kötelező interfészt implementálnia, csupán a megfelelő szignatúrájú függvényeket (`Configure`, `ConfigureServices` - opcionális) fogja az ASP.NET Core keresni.

T> Később érdemes megnézni a `CreateDefaultBuilder` implementációját, de most még nem sok mindent értenénk belőle.

#### Startup.cs

A `Startup` osztály tartalmazza az ASP.NET Core alkalmazásunk konfigurációját, ahol két kitüntetett metódus van.

A `ConfigureServices`-ben konfigurálhatjuk fel a dependency injection konténert. (lásd későbbi laborban)

A `Configure` metódusban pedig a middleware (mw) csővezetéket adjuk meg, tehát azokat a komponenseket, amelyeken a HTTP kérés feldolgozása fut végig. Az alábbi ábra szemlélteti a middleware pipeline működését, rajzoljuk fel a táblára.

![ASP.NET Core pipeline](images/aspnetcore1-pipeline.png)

Az ASP.NET Core alkalmazás alapszerkezete, hogy a befutó HTTP kérés (végig)fusson a middleware-ekből álló csővezetéken és valamelyik (alapesetben az utolsó) mw előállítja a választ, ami visszairányban halad (végig) a csővezetéken.

Esetünkben most csak két middleware-ünk van:

- Kivételkezelő middleware, ami az őt követő middleware-ek hibáit képes elkapni és ennek megfelelően egy hibaoldalt jelenít meg. Ez csak opcionálisan kerül beregisztrálásra attól függően, hogy most éppen *Development módban* futtatjuk-e az alkalmazást vagy sem. (lásd később)
- Egy egyetlen utasításból álló middleware, ami a válaszba ír egy *Hello World!* szöveget. Esetünkben ez termináló mw lesz, mivel ez már nem hív tovább a következő komponensbe, csak a választ írja ki. Figyeljük meg, hogy ez most egy lambda kifejezéssel kerül megadásra, viszont bonyolultabb esetben érdemes a middleware logikát egy külön osztályba kiszervezni (lásd később)

## Hosztolási lehetőségek

Próbáljuk ki IIS Expressen keresztül futtatva, azaz a VS-ben az indítógomb (zöld nyíl) mellett az IIS Express felirat legyen!

Két dolog is történik: az alkalmazásunk IIS Express webkiszolgálóban hosztolva kezd futni és egy böngésző is elindul, hogy ki tudjuk próbálni. Figyeljük meg a tálcán megjelenő IIS Express ikont és azon jobbklikkelve a hosztolt alkalmazás címét.

T> A böngésző panaszkodhat a nem megfelelő tanúsítványra (self-signed), kivételesen adjunk hozzá kivételt, hogy elfogadja.

T> A indítógomb legördülőjében a böngésző típusát is állíthatjuk.

T> Debuggerrel mutassuk meg, hogy a `Main` ilyenkor is meghívódik, illetve, ahogy az egysoros middleware-ünk előállítja a választ.

T> Az IIS Express a Microsoft web szerverének (IIS) fejlesztői célra optimalizált változata. Alapvetően csak ugyanarról a gépről érkező (localhost) kéréseket szolgál ki.

A másik lehetőség, ha közvetlenül a konzolos alkalmazást szeretnénk futtatni, akkor ezt az indítógombot lenyitva a projekt nevét kiválasztva tehetjük meg. Ebben az esetben egy beágyazott web szerverhez (Kestrel) futnak be a kérések. Próbáljuk ki a Kestrelt közvetlenül futtatva!

Két dolog is történik: az alkalmazásunk konzolos alkalmazásként kezd futni, illetve az előző esethez hasonlóan a böngésző is elindul. Figyeljük meg a konzolban megjelenő naplóüzeneteket.

T> Bár ezek a hosztolási opciók fejlesztői környezetben nagyon kényelmesek, érdemes áttekinteni az éles hosztolási opciókat: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/?view=aspnetcore-2.2

Rakjunk most az utolsó middleware-ünk be egy kivétel dobást a kiírás helyett, hogy kipróbáljuk a hibakezelő MW-t.

```csharp
app.Run(async (context) =\>
{
    //leanpub-start-insert
    throw new Exception("Hiba");
    //await context.Response.WriteAsync(\"Hello World!\");
    //leanpub-end-insert
});
```

Próbáljuk ki!

Láthatjuk, hogy a kivételt a hibakezelő middleware elkapja és egy hibaoldalt jelenítünk meg, sőt még a konzolon is megjelenik naplóbejegyzésként.

## Alkalmazásbeállítások vs. indítási profilok

Figyeljük meg, hogy most Development konfigurációban fut az alkalmazás (konzolban a legelső sor). Ezt az információt a keretrendszer környezeti változó alapján állapítja meg. Ha a **lauchSettings.json** állományt megnézzük, akkor láthatjuk, hogy az *ASPNETCORE\_ENVIRONMENT* környezeti változó *Development*-re van állítva.

Próbáljuk ki Visual Studión kívülről futtatni. Projekten jobb gomb Open Folder → címsorba cmd + [Enter] → dotnet run.

Ugyanúgy fog indulni, mint VS-ből, mert az újabb .NET Core verziókban már a *dotnet run* is figyelembe veszi a **launchSettings.json**-t. Ha nem akarjuk ezt, akkor a \--no-launch-profile kapcsolót használhatjuk a *dotnet run* futtatásánál.

Most az alkalmazásunk Production módban indul el, és ha a *localhost:5000*-es oldalt szeretnénk megnyitni a böngészőben nem kapunk hibaoldalt, de a konzolon megjelenik a naplóbejegyzés.

T> A konzolban a setx ENV\_NAME Value utasítással tudunk felvenni, ami a konzol bezárásáig marad érvényben, ha permanensen akarjuk tartani ezt akkor ezt a /M kapcsolóval tudjuk megtenni. (Admin/nem admin konzolok különbözőképpen viselkednek)

Az alkalmazás számára a különböző beállításokat JSON állományokban tárolhatjuk, amelyek akár környezetenként különbözőek is lehetnek. A generált projektünkben ez az **appsettings.json**, nézzünk bele - főleg naplózási beállítások vannak benne. A fájl a Solution Explorer ablakban „kinyitható”, alatta megtaláljuk az **appsettings.Development.json**-t. Ez a *Development* nevű konfigurációra vonatkozó beállítások.

A Hello World kiírásunkat kommentezzük vissza.

```csharp
app.Run(async (context) =>
{
    //leanpub-start-insert
    //throw new Exception("Hiba");
    await context.Response.WriteAsync("Hello World!");
    //leanpub-end-insert
});
```

Próbáljuk ki a projektneves indítással és figyeljük meg, hogy ahányszor frissítünk a böngészőben a kérés megjelenik a konzolablakban *Info* előtaggal, tehát az info szintű naplóbejegyzések megjelennek. Jelen állás szerint a *Development* konfiguráció jut érvényre a fent tárgyalt **launchsettings.json** környezeti változó beállítása alapján, ami így érvényre juttatja az **appsettings.Development.json**-t.

VS-ből is tudjuk állítani a környezetei változókat, nem kell a **launchsettings.json**-ban kézzel varázsolni. A projekt tulajdonságok *Debug* lapján tudunk új indítási profilt megadni, illetve a meglévőeket módosítani. Válasszuk ki az aktuálisan használt profilunkat (projektneves), majd írjuk át az *ASPNETCORE\_ENVIRONMENT* környezeti változó értékét az *Environment Variables* részen mondjuk *Production*-re.

Indítsuk ezzel a profillal és figyeljük meg, hogy már nem jelennek meg info szintű naplóbejegyzések bárhogy is frissítgetjük a böngészőt. Oka: nincs **appsettings.Production.json**, így az általános **appsettings.json** jut érvényre.

T> Parancssorban a dotnet run –launch-profile [profilnév] kapcsolóval adhatjuk meg az indítási profilt.

T> A 2.0 előtti ASP.NET Core verzióknál utólag manuálisan kellett az alkalmazásbeállításokat kezelő modult felkonfigurálni (pl., hogy a Development.json felülírja az alap appsettings.json-t). Ezt ma már elintézi a `CreateDefaultBuilder` hívás. Érdemes most megnézni ennek a függvénynek a [konfigurációját](https://github.com/aspnet/AspNetCore/blob/v2.2.3/src/DefaultBuilder/src/WebHost.cs#L148.) (a kapcsolódó snippetek között is megtalálható a link).

T> Számos forrásból lehet konfigurációt megadni: parancssor, környezeti változó, fájl (ezt láttuk most), felhő (Azure Key Vault), stb. Ezek közül többet is használhatunk egyszerre, a különböző források konfigurációja a közös kulcsok mentén összefésülődik. A források (*provider*-ek) között sorrendet adunk meg, amikor regisztráljuk őket, a legutolsóként regisztrált provider konfigurációja a legerősebb. Az alapértelmezett provider-ek regisztrációját szintén elintézi a `CreateDefaultBuilder`.

### Statikus fájl mw

Hozzunk létre a projekt gyökerébe egy *wwwroot* nevű mappát (jobbklikk) és tegyünk egy képfájlt bele. (Ellophatjuk pl. a www.aut.bme.hu honlap bal felső sarkából a logo-t)

A statikus fájlkezelés a teljes modularitás jegyében egy külön middleware-ként implementálták a *Microsoft.AspNetCore.StaticFiles* nuget csomagban (az AspNetCore.App már függőségként tartalmazza, így nem kell feltennünk most), csak hozzá kell adnunk a pipeline-hoz. Mindig gondoljunk arra, hogy a `Configure` metódusban a mw-ek konfigurációjának sorrendje fontos, mindig az általunk szabályozott kódlefutási sorrendben fog a kérés a csővezetéken végigfutni.

```csharp
 public void Configure(
     IApplicationBuilder app,
     IHostingEnvironment env,
     ILoggerFactory loggerFactory)
 {
    //... hibakezelés

    //leanpub-start-insert
     app.UseStaticFiles();
    //leanpub-end-insert

    //... egysoros mw
 }
```

Próbáljuk ki! Láthatjuk hogy a *localhost:port* címen még mindig a *Hello World* szöveg tűnik fel, de amint a *localhost:port/\[képfájlnév\]*-vel próbálkozunk, a kép töltődik be. A static file MW megszakítja a pipeline futását, ha sikerül neki kiszolgálnia a fájlt, viszont ha nem, akkor továbbhív a következő MW-be.

T> Ezt az egysoros middleware-re tett törésponttal is szemléltethetjük. Figyeljünk arra, hogy csak az `await`-es sorra kerüljön a töréspont és ne az egész `app.Run` sorra, illetve csak akkor nézzük, hogy mi fut le, amikor a kép URL-re hívunk.

Próbáljuk ki úgy is, hogy kikommentezzük a staticfiles middleware-t. Így hiába hívunk bármilyen címre, a „Hello world!"-öt kapjuk vissza.

## Alkalmazásbeállítások vs. DI

Az alkalmazásbeállításokat kódban egy `IConfiguration` interfészt megvalósító objektumon keresztül érhetjük el. Az objektum életciklusát az ASP.NET Core DI konténere kezeli. Ha egy konstruktor szignatúrájában jelezzük, hogy az adott osztályban szeretnénk dolgozni a konfigurációs objektummal, akkor a DI alrendszer beinjektálja nekünk.

Valósítsuk meg ezt a `Startup` osztályban:

```csharp
//ctor snippet ajánlott
public Startup(IConfiguration configuration)
{
    Configuration = configuration;
}

public IConfiguration Configuration { get; }
```

A `Startup` függvény végén törésponton megállva megvizsgálhatjuk például a `Configuration["AllowedHosts"]` értéket - az appsettings.json szerint ennek \* értékűnek kell lennie.

## Mvc middleware - Web API

Minden API-nál nagyon magas szinten az a cél, hogy egy kérés hatására egy szerveroldali kódrészlet meghívódjon. ASP.NET Core-ban a kódrészleteket függvényekbe írjuk, a függvények pedig ún. *controllerek*-be kerülnek. Összességében tehát a cél, hogy a webes kérés hatására egy kontroller egy függvénye meghívódjon.

### DummyController

Hozzunk létre egy új mappát *Controllers* néven. A mappába hozzunk létre egy kontrollert (Add → Controller... → API Controller with read/write actions) `DummyController` néven. Ez a művelet hozzáad egy új nuget csomagot a projekthez, ami a kódgeneráláshoz (scaffolding) kell és le is generálja az új kontrollerünket. A kontrollerünk az *AspNetCore.Mvc* nuget csomagban található Controller osztályból származik. (Ezt a csomagot sem kell feltennünk, mivel az AspNetCore.App függősége)

Adjuk hozzá a DI konténerhez az MVC-s szolgáltatásokat, és adjuk hozzá a csővezetékhez az MVC mw-t. Az egysoros mw-t kommentezzük ki.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    //leanpub-start-insert
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
    //leanpub-end-insert
}

public void Configure(IApplicationBuilder app, HostingEnvironment env, ILoggerFactory     loggerFactory)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseStaticFiles();

    //leanpub-start-insert
    app.UseMvc();
    //leanpub-end-insert
    //... egysoros mw kikommentezve
}
```

Próbáljuk ki. Az alapoldal üres, viszont ha a */api/Dummy* címre hívunk, akkor megjelenik a `DummyController.Get` által visszaadott érték. Magyarázzuk el a routing szabályokat, hogy hogyan jut el a HTTP kérés alapján a végrehajtás a függvényig: attribútum alapú routing-ot használunk, azaz a kontroller osztályra és a függvényeire biggyesztett attribútumok határozzák meg, hogy a HTTP kérés adata (pl. URL) alapján melyik függvény hívódik meg.

T> A `SetCompatibilityVersion` függvénnyel szabályozhatjuk, hogy mennyire hassanak ránk az egyes verziókban bevezetett breaking change-ek. Mivel eleve 2.2-es projektet hoztunk létre, így ezzel jelezhetjük, hogy a 2.2-es verziós újdonságokkal megspékelt legmodernebb működést kérjük.

T> API-t publikáló alkalmazásoknál az attribútum alapú routing az ajánlott, de emellett vannak más megközelítések is, például Razor alapú weboldalaknál konvenció alapú routing az ajánlott. Bővebben a témakörről [itt](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-2.2) lehet olvasni.

Ha van időnk, próbáljuk ki az */api/Dummy/\[egész szám\]* címet is.

## IOption\<T\>

Fentebb láttuk, hogy a konfigurációt ki tudtuk olvasni az `IConfiguration` interfészen keresztül, de még jobb lenne, ha csoportosítva és csoportonként külön C# osztályokon keresztül látnánk őket.

T> Ezen alfejezethez tartozó legtöbb kódrészlet kóddarabkaként is elérhető.

Bővítsük az *appsettings.json*-t egy saját beállításcsoporttal (*DummySettings*):

```javascript
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  },
   //leanpub-start-insert
  "AllowedHosts": "*",
  "DummySettings": {
    "DefaultString": "My Value",
    "DefaultInt": 23,
    "SuperSecret":  "Spoiler Alert!!!"
  }
   //leanpub-end-insert
}
```

Hozzunk létre egy új mappát *Options* néven. A mappába hozzunk létre egy sima osztályt *DummySettings* néven, a szerkezete feleljen meg a JSON-ben leírt beállításcsoportnak:

```csharp
public class DummySettings
{
    public string DefaultString { get; set; }

    public int DefaultInt { get; set; }

    public string SuperSecret { get; set; }
}
```

A `ConfigureServices`-ben adjuk meg, hogy egy `DummySettings` példányt mi alapján kell inicializálni - a konfiguráció megfelelő szekciójára hivatkozzunk:

```csharp
public void ConfigureServices(IServiceCollection services)
{
     //leanpub-start-insert
    services.Configure<DummySettings>(
        Configuration.GetSection(nameof(DummySettings)));
     //leanpub-end-insert
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
}
```

A DI alrendszer így már beinjektálhatja, ahol csak igényeljük ezt a konstruktorban. Igénylejük a `DummyController` konstruktorban:

```csharp
private DummySettings options;

public DummyController(IOptions<DummySettings> options)
{
    this.options=options.Value;
}
```

T> Látható, hogy a beállítás `IOptions`-ba burkolva érkezik. Vannak az `IOptions`-nál okosabb burkolók is (pl. `IOptionMonitor`), ami például jelzi, ha megváltozik valamilyen beállítás. Bővebb információ az `IOptions` és társairól a hivatalos dokumentációban [található](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-2.2#general-options-configuration).

Az egész számot váró `Get` változatban használjuk fel az értékeket:

```csharp
[HttpGet("{id}", Name = "Get")]
public string Get(int id)
{
    return id % 2 == 0 ? options.DefaultString : options.DefaultInt.ToString();
}
```

Próbáljuk ki, hogy az */api/Dummy/\[páros szám\]*, illetve */api/Dummy/\[páratlan szám\]* a megfelelő értéket kapjuk-e vissza.

## User Secrets

A projekt könyvtára gyakran valamilyen verziókezelő (pl. git) kezelésében van. Ilyenkor gyakori probléma, hogy a konfigurációs fájlokba írt szenzitív információk (API kulcsok, adatbázis jelszavak) bekerülnek a verziókezelőbe. Ha egy publikus projekten dolgozunk, például publikus gitHub projekt, akkor ez komoly biztonsági kockázat lehet.

W> Ne tegyünk a verziókezelőbe szenzitív információkat. Gondoljunk arra is, hogy a verziókezelő nem felejt! Ami egyszer már bekerült, azt vissza is lehet nyerni belőle (history).

Ennek a problémának megoldására egy eszköz a *User Secrets* tároló. Jobbklikkeljünk a projekten a Solution Explorer ablakban, majd válasszuk a *Manage User Secrets* menüpontot. Ennek hatására megnyílik egy **secrets.json** nevű fájl. Vizsgáljuk meg hol is van ez a fájl: vigyük az egeret a fájlfül fölé - azt láthatjuk, hogy a fájl a felhasználónk saját könyvtárán belül van és az útvonal része egy GUID is. A projektfájlba (.csproj) bekerült ugyanez a GUID (a *UserSecretsId* címkébe).

Másoljuk át az **appsettings.json** tartalmát a **secrets.json**-be, vegyük ki a `DummySettings`-en kívüli részeket, végül írjuk át a titkos értéket (*SuperSecret*):

```javascript
{
  "DummySettings": {
    "DefaultString": "My Value",
    "DefaultInt": 23,
    "SuperSecret": "SECRET"
  }
}
```

Töréspontot letéve (pl. a `DummyController` konstruktorának végén) ellenőrizzük, hogy a titkos érték melyik fájlból jön. Fontos tudni, hogy a *User Secrets* tároló csak Development mód esetén jut érvényre, így figyeljünk rá, hogy a megfelelő módot indítsuk és a környezeti változók is jól legyenek beállítva.

Ez az eljárás tehát a futtató felhasználó saját könyvtárából a GUID alapján kikeresi a projekthez tartozó **secrets.json**-t, annak tartalmát pedig futás közben összefésüli az **appsettings.json** tartalmával. Így szenzitív adat nem kerül a projekt könyvtárába.

T> Mivel a *User Secrets* tároló csak Development mód esetén jut érvényre, így ha az éles változatnak szüksége van ezekre a titkos értékekre, akkor további trükkökre van szükség. Ilyen megoldás lehet, ha Azure Key Vault-ból [töltjük be](https://docs.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-2.2) a szenzitív beállításokat.

[^kestrel]: A Kestrel jelenleg már alkalmas arra, hogy kipublikáljuk közvetlenül a világhálóra, de mivel nem rendelkezik túl bő konfigurációs és biztonsági beállításokkal, így érdemes egy fejlettebb webszervert a Kestrel elé rakni proxy gyanánt, például az IIS-t vagy nginx-et.
