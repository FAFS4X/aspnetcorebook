# ASP.NET Core alapok

## Célkitűzés
A labor során a hallgatók megismerkednek az ASP.NET Core alapvető felépítésével. A labor kitér a middleware-ek működésére, a konfigurációra, majd az MVC keretrendszer segítségével egyszerű webes kérések kerülnek implementálásra, aminek során a beépített dependency injection keretrendszer is bemutatásra kerül. Majd a labor végén a szemléltetés céljából egy egyszerű middleware kerül megvalósításra hibakezelés címszóval.

## Projekt létrehozása
Ezen a laboron nem a klasszikus beépített API projektsablont fogjuk felhasználni, hanem egy üres ASP.NET Core projektből próbáljuk felépíteni és megérteni azt a funkcionalitást, amit egyébként az előre elkészített VS projektsablonok adának készen a kezünkbe.

### Generálás
Hozzunk létre a Visual Studioban egy új projektet: (C# / Web / ASP.NET Core Web Application (.NET Core)), a neve legyen HelloAspNetCore.
A következő dialógusablakban válasszuk ki az ASP.NET Core 2.0 opciót és azon belül a Empty sablont. Most szándékosan nem a Web Apit vagy a Web Applicationt választottuk mivel a labor célja egy általános ASP.NET Core alkalmazás működésének megismerése, amit most saját kezűleg fogunk felépíteni.

![These words will appear as the image caption](images/aspnetcore1-choosetemplate.png)

### Eredmény


Nézzük meg milyen project generálódott:
-   **.csproj**: (Projekten jobb gomb, edit .csproj) Projekt beállításait tartalmazza. Előző verziókhoz képest itt erősen építenek az alapértelmezett értékekre, hogy minnél karcsúbbra tudják fogni ezt az állományt.
    -   **SDK**: project típusa (Microsoft.NET.Sdk.Web), tooling funkcióit szabályozza
    -   **TargetFramework**: netcoreapp2.0 (.NET Core 2.0)
    -   **PackageReference**: NuGet csomagok
        -   Microsoft.AspNetCore.All 2.x
-   **Properties**: klasszikus VS grafikus felület a projekt beállításaira
    -   **launchSettings.json:** Properties node-ot lenyitva találjuk meg a debuggoláshoz szükséges beállításokat a hosztolás szempontjából
-   **Dependencies**: SDK és NuGet csomagfüggőségek kezelése
    -   Az AspNetCore.All csomag került be, ami egy metacsomag, összefog kb. minden MS fejlesztésű, ASP.NET.Core alapcsomagot, *a fordításnál képes a nem használt csomagokat kiszűrni. (RuntimeStore)*
-   **wwwroot**: statikusan kiszolgálandó fájlok alapértelmezett helye (jelenleg üres)

### Osztályok
#### Program.cs

Az előző ASP.NET verzióval ellentétben, itt már az ASP.NET Core alkalmazások is klasszikus konzolos alkalmazások is lehetnek, így az alkalmazás alapértelmezett belépési pontja a Program osztály statikus Main metódusa. Ebben alapértelmezetten az ASP.NET Core pipeline kerül inicializálásra és futtatásra a WebHostBuilder segítségével.

Itt az ASP.NET Core beépített webszerverét (Kestrel[^kestrel]) használjuk a beérkező HTTP kérések lekezelésére.

Az ASP.NET Core alkalmazásunk konfigurációja egy külön osztályban (Startup) helyezkedik el, amit explicit meg is adunk a buildernek.

#### Startup.cs

A Startup osztály tartalmazza az ASP.NET Core alkalmazásunk konfigurációját, ahol két kitüntetett metódus van.

A ConfigureServices-ben konfigurálhatjuk fel a dependency injection konténert. (lásd később)

A Configure metódusban pedig a middleware csővezetéket adjuk meg, tehát azokat a komponenseket, amelyeken a http kérés feldolgozása fut végig. Az alábbi ábra szemlélteti a middleware pipeline működését, rajzoljuk fel a táblára.

![ASP.NET Core pipeline](images/aspnetcore1-pipeline.png)

Esetünkben most csak 2 middleware-ünk van:

-   Kivételkezelő middleware, ami az őt követő middleware-ek hibáit képes elkapni és ennek megfelelően egy hibaoldalt jelenít meg. Ez csak opcionálisan kerül beregisztrálásra attól függően, hogy most éppen „Development módban" futtatjuk-e az alkalmazást vagy sem. (lásd később)
-   Hello World middleware, ami a válaszba ír egy „Hello World!" szöveget. Esetünkben ez termináló MW lesz, mivel ez már nem hív tovább a következő komponensbe, csak a választ írja ki. Figyeljük meg, hogy ez most egy lambda kifejezéssel kerül megadásra, viszont érdemes a middleware logikát egy külön osztályba kiszervezni (lásd később)

### Kipróbálás

Próbáljuk ki IIS Expressen keresztül futtatva!

A másik lehetőség, ha közvetlenül a konzolos alkalmazást szeretnénk futtatni, akkor ezt a Play gombot lenyitva a projekt nevét kiválasztva tehetjük meg. Ilyenkor a konzolra kiírt naplót is figyelemmel követhetjük.

Próbáljuk ki a Kestrelt közvetlenül futtatva! A zöld indító nyíl opcióit lenyitva válasszuk a projektünk nevét, majd futtatás.

Rakjunk most az utolsó middleware-ünk be egy kivétel dobást a kiírás helyett, hogy kipróbáljuk a hibakezelő MW-t.

{lang="csharp"}

    app.Run(async (context) =\>
    {
        //leanpub-start-insert
        throw new Exception(\"Hiba\");        
        //await context.Response.WriteAsync(\"Hello World!\");    
        //leanpub-end-insert        
    });

Próbáljuk ki!

Láthatjuk, hogy a kivételt a hibakezelő middleware elkapja és egy hibaoldalt jelenítünk meg, sőt még a konzolon is megjelenik naplóbejegyzésként.

### ASPNETCORE\_ENVIRONMENT környezeti változó

Figyeljük meg, hogy most Development konfigurációban fut az alkalmazás (konzolban a legelső sor). Ezt az információt a keretrendszer környezeti változó alapján állapítja meg. Ha a Properties / lauchSettings.json állományt megnézzük, akkor láthatjuk, hogy az ASPNETCORE\_ENVIRONMENT változó Development-re van állítva.

Próbáljuk ki Visual Studion kívülről futtatni. Projekten jobb gomb Open Folder / Open Command Prompt / dotnet run.

Ugyanúgy fog indulni, mint VS-ből, mert az újabb .NET Core verziókban már a dotnet run is figyelembe veszi a launchSettings.json-t. Ha nem akarjuk ezt, akkor a \--no-launch-profile kapcsolót használhatjuk a dotnet run futtatásánál.

Most az alkalmazásunk Production módban indul el, és ha a localhost:5000-es oldalt szeretnénk megnyitni a böngészőben nem kapunk hibaoldalt, de a konzolon megjelenik a naplóbejegyzés.

T> Megj.: konzolban a setx ENV\_NAME Value utasítással tudunk felvenni, ami a konzol bezárásáig marad érvényben, ha permanensen akarjuk tartani ezt akkor ezt a /M kapcsolóval tudjuk megtenni. (Admin/nem admin konzolok különbözőképpen viselkednek)

### Alkalmazásbeállítások vs. indítási profilok

Az alkalmazás számára a különböző beállításokat JSON állományokban tárolhatjuk, amelyek akár környezetenként különbözőek is lehetnek.

Vegyünk fel a projekt gyökerébe egy appsettings.json fájlt: (Add new item / ASP.NET Configuration File).

Ez most egy connection stringet vett fel alapértelmezetten, de mi most inkább használjunk fel a naplózás konfigurálására, így tartalma legyek a következő:

    {
      "Logging": {
        "LogLevel": {
          "Default": "Warning"
        }
      }
    }

    
A Hello World kiírásunkat kommentezzük vissza.
    
    public void Configure(
        IApplicationBuilder app, IHostingEnvironment env)
    {  
        //...   
    
        app.Run(async (context) =>
        {
            //leanpub-start-insert
            //throw new Exception("Hiba");
            await context.Response.WriteAsync("Hello World!");
            //leanpub-end-insert
        });
    }

Próbáljuk ki! Figyeljük meg, hogy most a HTTP kérésekről (INFO szint) nem keletkeznek naplóbejegyzések, mivel csak a Warning vagy az attól erősebb események kerülnek naplózásra.

Készítsünk egy környezet specifikus változatot ehhez a JSON fájlhoz appsettings.Development.json néven, ami akkor fog betöltődni, ha Development környezetben futtatjuk az alkalmazásunkat. Itt már a Debug szintű bejegyzéseket is jelenítsük meg, viszont a System és a Microsoft-hoz köthető logbejegyzések esetében csak az Information szintet. Tartalma legyen a következő:

    {
      "Logging": {
        "LogLevel": {
          "Default": "Debug",
          "System": "Information",
          "Microsoft": "Information"
        }
      }
    }

Próbáljuk ki! Azt tapasztaljuk, hogy az appsettings.json állományunkban csak a Warning szintet engedjük át, addig a Development környezeti változóval indított alkalmazás, már az Info szintet is átengedi a kérések naplózása során. Az appsettings.Development.json állományban található naplózó beállítások (azonos kulcsú elemek) felülírták az appsettings.json állományban található konfigurációt.

VS-ből is tudjuk állítani a környezetei változókat, nem kell a konzolban varázsolni. A projekt tulajdonságok Debug lapján tudunk új indítási profilt megadni, illetve a meglévőeket módosítani. Vegyünk fel egy új konfigurációt a New... gombbal. Adjunk neki nevet, majd adjuk meg, hogy
-   a Project induljon (Launch)
-   és egy böngésző is (Launch Browser-hez pipa)

Mentsünk, majd, nézzük meg, hogy igazából a Properties/launchSettings.json-t szerkesztettük, bekerült az új indítási konfigurációnk. A zöld nyíl mellett, most már ezt is ki tudjuk választani. Tegyünk is így. Indítsuk el. Mivel ebben az indítási profilban nincs beállítva a Development mód (nincs meg ehhez az ASPNETCORE_ENVIRONMENT), ezért az alap appsettings.json fog csak érvényre jutni, azaz újra nem látszódnak a HTTP kérésekről a naplóbejegyzések.

Vátsunk vissza development-es indítási profilra.

T> Parancssorban a dotnet run –launch-profile [profilnév] kapcsolóval adhatjuk meg az indítási profilt.
T> A 2.0 előtti ASP.NET Core verzióknál utólag „kézzel” kellett az alkalmazásbeállításokat kezelő modult felkonfigurálni (pl., hogy a Development.json felülírja az alap appsettings.json-t). Ezt ma már elintézi a Main függvényben lévő CreateDefaultBuilder hívás.
T> Érdemes megnézni ennek a konfigurációját, a https://github.com/bmeaut/dotnet/blob/master/aspnetcore1.md-ban található rá a link.[^webhost]

![ASP.NET Core debug](images/aspnetcore1-debug.png)

### Statikus fájlok

Rakjunk egy képfájlt a wwwroot mappába. (Ellophatjuk pl. az AUT honlap bal felső sarkából a logo-t)

A statikus fájlkezelés, a teljes modularitás jegyében egy külön middleware-ként került implementálásra a Microsoft.AspNetCore.StaticFiles nuget csomagban (az AspNetCore.All már függőségként tartalmazza, így nem kell feltennünk most), csak hozzá kell adnunk a pipline.hoz. Mindig gondoljunk arra, hogy a Configure metódusban a MW-ek konfigurációjának sorrendje fontos, mindig az általunk megadott sorrendben fog a kérés a csővezetéken végigfutni.

    public void Configure(
        IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        //... hibakezelés
    
       //leanpub-start-insert
        app.UseStaticFiles();
       //leanpub-end-insert

        app.Run(async (context) =>
        {
            //throw new Exception("Hiba");
            await context.Response.WriteAsync("Hello World!");
        });
    }

Próbáljuk ki! Láthatjuk hogy a localhost:port címen még mindig a Hello World szöveg tűnik fel, de amint a localhost:port/\[képfájlnév\]-el próbálkozunk a html oldal töltődik be. A static file MW megszakítja a pipeline futását, ha sikerül neki kiszolgálnia a fájlt, viszont ha nem, akkor továbbhív a következő MW-be.

Próbáljuk ki úgy is, hogy kivesszük a staticfiles middleware-t. Így hiába hívunk bármilyen címre, a „Hello world!"-öt kapjuk vissza.

## Web API
Minden API-nál nagyon magas szinten az a cél, hogy egy kérés hatására egy szerveroldali kódrészlet meghívódjon. ASP.NET Core-ban a kódrészleteket függvényekbe írjuk, a függvények pedig ún. controllerek-be kerülnek. Összességében tehát a cél, hogy a webes kérés hatására egy kontroller egy függvénye meghívódjon.

### DummyController
Hozzunk létre egy új mappát Controllers néven. A mappába hozzunk létre egy kontrollert (Add / Controller... / API Controller with read/write actions) DummyController néven. Ez a művelet hozzáad egy új nuget csomagot a projekthez, ami a kódgeneráláshoz kell és le is generálja az új controllerünket. A kontrollerünk az AspNetCore.Mvc nuget csomagban található Controller osztályból szrámazik. (Ezt a csomagot sem kell feltennünk, mivel az AspNetCore.All függősége)

Adjuk hozzá a DI konténerhez az MVC-s szolgáltatásokat, és adjuk hozzá a pipelinehoz az MVC middleware-t. A Hello World middleware-t kommentezzük ki.

    public void ConfigureServices(IServiceCollection services)
    {
        //leanpub-start-insert
        services.AddMvc();
        //leanpub-end-insert
    }
    
    
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory     loggerFactory)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
    
        app.UseStaticFiles();
    
        //leanpub-start-insert
        app.UseMvc(routes =>
        {
            routes.MapRoute(
                name: "default",
                template: "{controller=Home}/{action=Index}/{id?}");
        });
        //leanpub-end-insert
        //..
    }

Próbáljuk ki. Az alapoldal üres, viszont ha a /api/Dummy oldalra hívunk, akkor megjelenik a DummyController.Get által visszaadott érték. Magyarázzuk el a routing szabályokat, hogy hogyan jut el a HTTP kérés alapján a vágrehajtás a függvényig.

### Hibakezelés
Mi történik, ha a gyökércímre hívunk? A konzolnapló szerint 404-es hiba. A kliensoldal (böngésző) ebből nem sokat jelenít meg. API-k esetén a nem várt hibákat szerveroldalon naplózzuk, a kliensre minimális információt adjunk vissza (exception shielding), konkrét exception adatot, stack trace-t ne (security szempontból információszivárgás)! A felhasználó által elkövetett hibák, pl. vaildációs hibák esetén a kliensen igényes hibaüzenetet adjunk.

#### Státusz kódok kezelése
Ha a kérés alapján a controller/függvény nem található meg, 404-es válasz keletkezik. Hiba típusú státuszkódok kezelésére egy alapszintű megoldás a StatusCodesPages middleware. Ez egy sima szöveget küld vissza a hibakód mellett. A Configure függvénybe:
 
    app.UseStaticFiles();
    //leanpub-start-insert
    app.UseStatusCodePages();
    //leanpub-end-insert
    app.UseMvc(routes => …
    
T> Ezt a middleware-t még lehet tovább konfigurálni, kódonként külön kimenetet megadni, vagy átírányítani egy kontrollerfüggvényhez, hogy az állítsa elő a választ a státuszkód alapján.

Próbáljuk ki így - egy rövid szöveges üzenet jelenik meg a böngészőben.

### Kivételek kezelése
A hibák általában kivételként keletkeznek, amit valahol egy hibakódot (és esetlegesen extra infót, hibaüzenetet) tartalmazó HTTP válasszá alakítunk. Az átalakítás megtörténhet a controller függvényben, de ehhez el kell kapnunk a kivételeket. Mi történik, ha nem kapjuk el? DummyController.Get elején szimuláljuk ezt, dobjunk kivételt:
  
    [HttpGet]
    public IEnumerable<string> Get()
    {
        //leanpub-start-insert
        throw new NullReferenceException();
        //leanpub-end-insert
        return new string[] { "value1", "value2" };
    }

Próbáljunk ráhívni az api/Dummy címre: Development módban a kivétel szinte minden adata megjelenik (biztonsági kockázat, de dev módban bocsánatos bűn), ha development mód nélküli indítási profilt használunk, akkor egy üres 500-as hibát kapunk. Ez amiatt van, mert a DeveloperExceptionPage csak development indítási módban kerül bele a pipeline-ba.

Biztonsági szempontból ez az állapot sem rossz, de ha ennél azért több infót akarunk visszaadni a kliensnek, akkor érdemes a nem elkapott kivételeket érdemes közös helyen lekezelni. Erre jó az ExceptionHandler middleware.

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    //leanpub-start-insert
    else
    {
        app.UseExceptionHandler("/error");
    }
    //leanpub-end-insert
    
A DummyController-be vegyünk fel egy függvényt, aminek a route-ja /error.

    [Route("/error")]
    public IActionResult Index()
    {
        return StatusCode(StatusCodes.Status500InternalServerError, "Hibaa");
    }
    

Próbáljuk ki egy nem development módú indítási profillal az api/Dummy címet. A függvényben megadott szöveg fog megjelenni.

T> A kivétel adatait meg lehet szerezni a függvényben a HttpContext.Features.Get<IExceptionHandlerFeature>() függvénnyel.

[^kestrel]: A Kestrel jelenleg már alkalmas arra, hogy kipublikáljuk
    közvetlenül a világhálóra, de mivel nem rendelkezik túl bő
    konfigurációs és biztonsági beállításokkal, így érdemes egy sokkal
    fejlettebb webszervert a Kestrel elé rakni proxy gyanánt, például az
    IIS-t.

[^webhost]: Ide is beszúrjuk: <https://github.com/aspnet/MetaPackages/blob/rel/2.0.0/src/Microsoft.AspNetCore/WebHost.cs>. A fájl alján van a CreateDefaultBuilder.