# Entity Framework Core

## Célkitűzés
A labor célja, hogy a hallgatók megismerkedjenek az Entity Framework Core alapjaival, ezen belül is részletesebben a Code-First alapú fejlesztéssel.

## Előfeltételek
- Visual Studio 2017 
- .NET Core SDK

## Az Entity Framework mapping módszerei
Az OR leképzés két részből áll, az egyik az adatbázis séma, a másik pedig egy menedzselt kódbéli objektum modell. Esetünkben a C# kódban lévő osztályokat képezzük le adatbázisbeli objektumokká, ezt hívjuk Code-First mapping módszernek. A másik irány is lehetséges, ha már van egy adatbázis sémánk, akkor azt is leképezhetjük Code-First modellé. Ezt a folyamatot Reverse Engeniered Code-First-nek hívjuk, de ezt általában csak kompatibilitási célból szoktuk használni.

### A Code-first mapping módszer
A Code-First lényege, hogy elsőként az OO entitásokat definiáljuk egyszerűen programkódban, majd a mapping-et szintén programkódban. A mapping alapján az EF képes az adatbázis létrehozására, inicializálására és a séma változáskövetésére is (Migrations).

![ASP.NET Core templates](images/aspnetcore1-choosetemplate.png)

### Az entitások definiálása

Készítsünk egy konzolos alkalmazást, majd a projekten belül hozzunk létre egy Entities mappát. Adjunk hozzá a mappához egyszerű osztályokat az alábbi sémának megfelelően:
    - Product (Id:int, Name:string, UnitPrice:int)
    - Order (Id:int, OrderDate:DateTime)
    - Category (Id:int, CategoryName:string) 
Az osztályok legyenek publikusak, az attribútumok pedig egyszerű auto-implementált property-k (prop snippet). 

### Mapping és egyéb metaadatok megadása I.

Eddig megadtuk az entitás nevét, az attribútumok nevét és típusát, azonban ezen felül még sok mindent lehet/kell megadni: az entitás elsődleges kulcsa idegen kulcsok, relációk, kényszerek és egyéb mapping információk (pl. hogy mi legyen az attribútum oszlopneve az adatbázisban). A Code-First stratégia kétfajta módszert is kínál a megadásra. Az egyik módszer, hogy attribútumokat helyezünk az entitásosztályok különböző részeire, a másik, hogy ún. fluent jellegű kódot alkalmazunk. Ez utóbbi módszer elsőre furcsán néz ki, de többet tud (van, amit attribútummal nem lehet megadni).
A fenti két módszert kiegészíti a konvenció alapú konfiguráció, amikor az EF a rendelkezésekre álló adatokból automatikusan következteti ki a metaadatokat: pl. gyakori, hogy az elsődleges kulcs neve tartalmazza az „id” szöveget. Az EF tehát a konvenció alapján kitalálhatja, hogy melyik ez elsődleges kulcs oszlop. Ha valamit rosszul találna ki, vagy változtatni akarunk a kitalált neveken, akkor az attribútumos vagy fluent megadással tehetjük meg.
T> EF 6-ban saját konvenciókat is megadhatunk, viszont Core-ban (még) nem.

Elsőként azt nézzük meg, hogy mit talál ki az EF, ha semmi plusz adatot nem adunk meg.

### Relációk

Az entitások közötti kapcsolatokat mutatja az alábbi ábra:

![EF Core kapcsolatok](images/efcore-rels.png)

A Product-Category egy-többes kapcsolathoz egy idegen kulcs property és egy navigációs property tartozik a `Product` osztályban és egy navigációs property a `Category`-ban. A többes navigációs property-k legyenek csak olvashatók és a típusuk legyen `ICollection<>`.

T> Általánosságban nem kötelező egy kapcsolat mindkét oldalán navigációs property-t felvenni, de erősen javasolt és mindig jó, ha van. Az entitáson végzendő műveleteket egyszerűsíti, illetve a konvenciós logika is következtet belőle.

Az Order-Product több-többes kapcsolatothoz nem elég egy-egy kollekciót felvenni a két osztályban. Létre kell hozzuk a kapcsolótáblának megfelelő entitást is, ami egy-egy Product és Order közötti kapcsolatot reprezentálja.

    - **ProductOrders** (ProductId:int, OrderId:int)
  
![Product-Order kapcsolótábla](images/efcore-bridgetab.png)

Ezután így néznek ki az entitások (segítség a gépeléshez: bit.ly/dotnetlabor6-7)

<<(code/efcore-category.cs)
<<(code/efcore-order.cs)
<<(code/efcore-product.cs)
<<(code/efcore-productorder.cs)

### Kipróbálás

Próbáljuk ki IIS Expressen keresztül futtatva!

A másik lehetőség, ha közvetlenül a konzolos alkalmazást szeretnénk futtatni, akkor ezt a Play gombot lenyitva a projekt nevét kiválasztva tehetjük meg. Ilyenkor a konzolra kiírt naplót is figyelemmel követhetjük.

Próbáljuk ki a Kestrelt közvetlenül futtatva! A zöld indító nyíl opcióit lenyitva válasszuk a projektünk nevét, majd futtatás.

Rakjunk most az utolsó middleware-ünk be egy kivétel dobást a kiírás helyett, hogy kipróbáljuk a hibakezelő MW-t.

```csharp
app.Run(async (context) =\>
{
    //leanpub-start-insert
    throw new Exception(\"Hiba\");        
    //await context.Response.WriteAsync(\"Hello World!\");    
    //leanpub-end-insert        
});
```

Próbáljuk ki!

Láthatjuk, hogy a kivételt a hibakezelő middleware elkapja és egy hibaoldalt jelenítünk meg, sőt még a konzolon is megjelenik naplóbejegyzésként.

### ASPNETCORE\_ENVIRONMENT környezeti változó

Figyeljük meg, hogy most Development konfigurációban fut az alkalmazás (konzolban a legelső sor). Ezt az információt a keretrendszer környezeti változó alapján állapítja meg. Ha a Properties / lauchSettings.json állományt megnézzük, akkor láthatjuk, hogy az ASPNETCORE\_ENVIRONMENT változó Development-re van állítva.

Próbáljuk ki Visual Studion kívülről futtatni. Projekten jobb gomb Open Folder / Open Command Prompt / dotnet run.

Ugyanúgy fog indulni, mint VS-ből, mert az újabb .NET Core verziókban már a dotnet run is figyelembe veszi a launchSettings.json-t. Ha nem akarjuk ezt, akkor a \--no-launch-profile kapcsolót használhatjuk a dotnet run futtatásánál.

Most az alkalmazásunk Production módban indul el, és ha a localhost:5000-es oldalt szeretnénk megnyitni a böngészőben nem kapunk hibaoldalt, de a konzolon megjelenik a naplóbejegyzés.

T> Megj.: konzolban a setx ENV\_NAME Value utasítással tudunk felvenni, ami a konzol bezárásáig marad érvényben, ha permanensen akarjuk tartani ezt akkor ezt a /M kapcsolóval tudjuk megtenni. (Admin/nem admin konzolok különbözőképpen viselkednek)

### Alkalmazásbeállítások vs. indítási profilok

Az alkalmazás számára a különböző beállításokat JSON állományokban tárolhatjuk, amelyek akár környezetenként különbözőek is lehetnek.

Vegyünk fel a projekt gyökerébe egy appsettings.json fájlt: (Add new item / ASP.NET Configuration File).

Ez most egy connection stringet vett fel alapértelmezetten, de mi most inkább használjunk fel a naplózás konfigurálására, így tartalma legyek a következő:
```javascript
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  }
}
```
    
A Hello World kiírásunkat kommentezzük vissza.

```csharp
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{  
    //...   

    app.Run(async (context) =>
    {
        //leanpub-start-insert
        //throw new Exception("Hiba");
        await context.Response.WriteAsync("Hello World!");
        //leanpub-end-insert
    });
}
```

Próbáljuk ki! Figyeljük meg, hogy most a HTTP kérésekről (INFO szint) nem keletkeznek naplóbejegyzések, mivel csak a Warning vagy az attól erősebb események kerülnek naplózásra.

Készítsünk egy környezet specifikus változatot ehhez a JSON fájlhoz appsettings.Development.json néven, ami akkor fog betöltődni, ha Development környezetben futtatjuk az alkalmazásunkat. Itt már a Debug szintű bejegyzéseket is jelenítsük meg, viszont a System és a Microsoft-hoz köthető logbejegyzések esetében csak az Information szintet. Tartalma legyen a következő:

```javascript
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "System": "Information",
      "Microsoft": "Information"
    }
  }
}
```

Próbáljuk ki! Azt tapasztaljuk, hogy az appsettings.json állományunkban csak a Warning szintet engedjük át, addig a Development környezeti változóval indított alkalmazás, már az Info szintet is átengedi a kérések naplózása során. Az appsettings.Development.json állományban található naplózó beállítások (azonos kulcsú elemek) felülírták az appsettings.json állományban található konfigurációt.

VS-ből is tudjuk állítani a környezetei változókat, nem kell a konzolban varázsolni. A projekt tulajdonságok Debug lapján tudunk új indítási profilt megadni, illetve a meglévőeket módosítani. Vegyünk fel egy új konfigurációt a New... gombbal. Adjunk neki nevet, majd adjuk meg, hogy
-   a Project induljon (Launch)
-   és egy böngésző is (Launch Browser-hez pipa)

Mentsünk, majd, nézzük meg, hogy igazából a Properties/launchSettings.json-t szerkesztettük, bekerült az új indítási konfigurációnk. A zöld nyíl mellett, most már ezt is ki tudjuk választani. Tegyünk is így. Indítsuk el. Mivel ebben az indítási profilban nincs beállítva a Development mód (nincs meg ehhez az ASPNETCORE_ENVIRONMENT), ezért az alap appsettings.json fog csak érvényre jutni, azaz újra nem látszódnak a HTTP kérésekről a naplóbejegyzések.

Vátsunk vissza development-es indítási profilra.

T> Parancssorban a dotnet run –launch-profile [profilnév] kapcsolóval adhatjuk meg az indítási profilt.
T> A 2.0 előtti ASP.NET Core verzióknál utólag „kézzel” kellett az alkalmazásbeállításokat kezelő modult felkonfigurálni (pl., hogy a Development.json felülírja az alap appsettings.json-t). Ezt ma már elintézi a Main függvényben lévő CreateDefaultBuilder hívás.
T> Érdemes megnézni ennek a konfigurációját, a https://github.com/bmeaut/dotnet/blob/master/aspnetcore1.md-ban található rá a link.[^webhost]

![ASP.NET Core debug](images/aspnetcore1-debug.png)

### Statikus fájlok

Rakjunk egy képfájlt a wwwroot mappába. (Ellophatjuk pl. az AUT honlap bal felső sarkából a logo-t)

A statikus fájlkezelés, a teljes modularitás jegyében egy külön middleware-ként került implementálásra a Microsoft.AspNetCore.StaticFiles nuget csomagban (az AspNetCore.All már függőségként tartalmazza, így nem kell feltennünk most), csak hozzá kell adnunk a pipline.hoz. Mindig gondoljunk arra, hogy a Configure metódusban a MW-ek konfigurációjának sorrendje fontos, mindig az általunk megadott sorrendben fog a kérés a csővezetéken végigfutni.

```csharp
 public void Configure(
     IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
 {
     //... hibakezelés
 
    //leanpub-start-insert
     app.UseStaticFiles();
    //leanpub-end-insert

     app.Run(async (context) =>
     {
         //throw new Exception("Hiba");
         await context.Response.WriteAsync("Hello World!");
     });
 }
```

Próbáljuk ki! Láthatjuk hogy a localhost:port címen még mindig a Hello World szöveg tűnik fel, de amint a localhost:port/\[képfájlnév\]-el próbálkozunk a html oldal töltődik be. A static file MW megszakítja a pipeline futását, ha sikerül neki kiszolgálnia a fájlt, viszont ha nem, akkor továbbhív a következő MW-be.

Próbáljuk ki úgy is, hogy kivesszük a staticfiles middleware-t. Így hiába hívunk bármilyen címre, a „Hello world!"-öt kapjuk vissza.

## Web API
Minden API-nál nagyon magas szinten az a cél, hogy egy kérés hatására egy szerveroldali kódrészlet meghívódjon. ASP.NET Core-ban a kódrészleteket függvényekbe írjuk, a függvények pedig ún. controllerek-be kerülnek. Összességében tehát a cél, hogy a webes kérés hatására egy kontroller egy függvénye meghívódjon.

### DummyController
Hozzunk létre egy új mappát Controllers néven. A mappába hozzunk létre egy kontrollert (Add / Controller... / API Controller with read/write actions) DummyController néven. Ez a művelet hozzáad egy új nuget csomagot a projekthez, ami a kódgeneráláshoz kell és le is generálja az új controllerünket. A kontrollerünk az AspNetCore.Mvc nuget csomagban található Controller osztályból szrámazik. (Ezt a csomagot sem kell feltennünk, mivel az AspNetCore.All függősége)

Adjuk hozzá a DI konténerhez az MVC-s szolgáltatásokat, és adjuk hozzá a pipelinehoz az MVC middleware-t. A Hello World middleware-t kommentezzük ki.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    //leanpub-start-insert
    services.AddMvc();
    //leanpub-end-insert
}

public void Configure(IApplicationBuilder app, HostingEnvironment env, ILoggerFactory     loggerFactory)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseStaticFiles();

    //leanpub-start-insert
    app.UseMvc(routes =>
    {
        routes.MapRoute(
            name: "default",
            template: "{controller=Home}/{action=Index}/{id?}");
    });
    //leanpub-end-insert
    //..
}
```

Próbáljuk ki. Az alapoldal üres, viszont ha a /api/Dummy oldalra hívunk, akkor megjelenik a DummyController.Get által visszaadott érték. Magyarázzuk el a routing szabályokat, hogy hogyan jut el a HTTP kérés alapján a vágrehajtás a függvényig.

### Hibakezelés
Mi történik, ha a gyökércímre hívunk? A konzolnapló szerint 404-es hiba. A kliensoldal (böngésző) ebből nem sokat jelenít meg. API-k esetén a nem várt hibákat szerveroldalon naplózzuk, a kliensre minimális információt adjunk vissza (exception shielding), konkrét exception adatot, stack trace-t ne (security szempontból információszivárgás)! A felhasználó által elkövetett hibák, pl. vaildációs hibák esetén a kliensen igényes hibaüzenetet adjunk.

#### Státusz kódok kezelése
Ha a kérés alapján a controller/függvény nem található meg, 404-es válasz keletkezik. Hiba típusú státuszkódok kezelésére egy alapszintű megoldás a StatusCodesPages middleware. Ez egy sima szöveget küld vissza a hibakód mellett. A Configure függvénybe:
 
```csharp
app.UseStaticFiles();
//leanpub-start-insert
app.UseStatusCodePages();
//leanpub-end-insert
app.UseMvc(routes => …
```
    
T> Ezt a middleware-t még lehet tovább konfigurálni, kódonként külön kimenetet megadni, vagy átírányítani egy kontrollerfüggvényhez, hogy az állítsa elő a választ a státuszkód alapján.

Próbáljuk ki így - egy rövid szöveges üzenet jelenik meg a böngészőben.

### Kivételek kezelése
A hibák általában kivételként keletkeznek, amit valahol egy hibakódot (és esetlegesen extra infót, hibaüzenetet) tartalmazó HTTP válasszá alakítunk. Az átalakítás megtörténhet a controller függvényben, de ehhez el kell kapnunk a kivételeket. Mi történik, ha nem kapjuk el? DummyController.Get elején szimuláljuk ezt, dobjunk kivételt:
  
```csharp
[HttpGet]
public IEnumerable<string> Get()
{
    //leanpub-start-insert
    throw new NullReferenceException();
    //leanpub-end-insert
    return new string[] { "value1", "value2" };
}
```

Próbáljunk ráhívni az api/Dummy címre: Development módban a kivétel szinte minden adata megjelenik (biztonsági kockázat, de dev módban bocsánatos bűn), ha development mód nélküli indítási profilt használunk, akkor egy üres 500-as hibát kapunk. Ez amiatt van, mert a DeveloperExceptionPage csak development indítási módban kerül bele a pipeline-ba.

Biztonsági szempontból ez az állapot sem rossz, de ha ennél azért több infót akarunk visszaadni a kliensnek, akkor érdemes a nem elkapott kivételeket érdemes közös helyen lekezelni. Erre jó az ExceptionHandler middleware.

```csharp
 if (env.IsDevelopment())
 {
     app.UseDeveloperExceptionPage();
 }
 //leanpub-start-insert
 else
 {
     app.UseExceptionHandler("/error");
 }
 //leanpub-end-insert
```

A DummyController-be vegyünk fel egy függvényt, aminek a route-ja /error.

```csharp
[Route("/error")]
public IActionResult Index()
{
    return StatusCode(StatusCodes.Status500InternalServerError, "Hibaa");
}
```

Próbáljuk ki egy nem development módú indítási profillal az api/Dummy címet. A függvényben megadott szöveg fog megjelenni.

T> A kivétel adatait meg lehet szerezni a függvényben a HttpContext.Features.Get<IExceptionHandlerFeature>() függvénnyel.

[^kestrel]: A Kestrel jelenleg már alkalmas arra, hogy kipublikáljuk
    közvetlenül a világhálóra, de mivel nem rendelkezik túl bő
    konfigurációs és biztonsági beállításokkal, így érdemes egy sokkal
    fejlettebb webszervert a Kestrel elé rakni proxy gyanánt, például az
    IIS-t.

[^webhost]: Ide is beszúrjuk: <https://github.com/aspnet/MetaPackages/blob/rel/2.0.0/src/Microsoft.AspNetCore/WebHost.cs>. A fájl alján van a CreateDefaultBuilder.