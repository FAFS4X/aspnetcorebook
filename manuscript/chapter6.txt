# Entity Framework Core

## Célkitűzés

A labor célja, hogy a hallgatók megismerkedjenek az Entity Framework Core alapjaival, ezen belül is részletesebben a Code-First alapú fejlesztéssel.

## Előfeltételek

- Visual Studio 2017
- .NET Core SDK

## Az Entity Framework mapping módszerei

Az OR leképzés két részből áll, az egyik az adatbázis séma, a másik pedig egy menedzselt kódbéli objektum modell. Esetünkben a C# kódban lévő osztályokat képezzük le adatbázisbeli objektumokká, ezt hívjuk Code-First mapping módszernek. A másik irány is lehetséges, ha már van egy adatbázis sémánk, akkor azt is leképezhetjük Code-First modellé. Ezt a folyamatot Reverse Engeniered Code-First-nek hívjuk, de ezt általában csak kompatibilitási célból szoktuk használni.

### A Code-first mapping módszer

A Code-First lényege, hogy elsőként az OO entitásokat definiáljuk egyszerűen programkódban, majd a mapping-et szintén programkódban. A mapping alapján az EF képes az adatbázis létrehozására, inicializálására és a séma változáskövetésére is (Migrations).

![ASP.NET Core templates](images/aspnetcore1-choosetemplate.png)

### Az entitások definiálása

Készítsünk egy konzolos alkalmazást, majd a projekten belül hozzunk létre egy Entities mappát. Adjunk hozzá a mappához egyszerű osztályokat az alábbi sémának megfelelően:

- Product (Id:int, Name:string, UnitPrice:int)
- Order (Id:int, OrderDate:DateTime)
- Category (Id:int, CategoryName:string)
Az osztályok legyenek publikusak, az attribútumok pedig egyszerű auto-implementált property-k (prop snippet).

### Mapping és egyéb metaadatok megadása I.

Eddig megadtuk az entitás nevét, az attribútumok nevét és típusát, azonban ezen felül még sok mindent lehet/kell megadni: az entitás elsődleges kulcsa idegen kulcsok, relációk, kényszerek és egyéb mapping információk (pl. hogy mi legyen az attribútum oszlopneve az adatbázisban). A Code-First stratégia kétfajta módszert is kínál a megadásra. Az egyik módszer, hogy attribútumokat helyezünk az entitásosztályok különböző részeire, a másik, hogy ún. fluent jellegű kódot alkalmazunk. Ez utóbbi módszer elsőre furcsán néz ki, de többet tud (van, amit attribútummal nem lehet megadni).
A fenti két módszert kiegészíti a konvenció alapú konfiguráció, amikor az EF a rendelkezésekre álló adatokból automatikusan következteti ki a metaadatokat: pl. gyakori, hogy az elsődleges kulcs neve tartalmazza az „id” szöveget. Az EF tehát a konvenció alapján kitalálhatja, hogy melyik ez elsődleges kulcs oszlop. Ha valamit rosszul találna ki, vagy változtatni akarunk a kitalált neveken, akkor az attribútumos vagy fluent megadással tehetjük meg.

T> EF 6-ban saját konvenciókat is megadhatunk, viszont Core-ban (még) nem.

Elsőként azt nézzük meg, hogy mit talál ki az EF, ha semmi plusz adatot nem adunk meg.

### Relációk

Az entitások közötti kapcsolatokat mutatja az alábbi ábra:

![EF Core kapcsolatok](images/efcore-rels.png)

A Product-Category egy-többes kapcsolathoz egy idegen kulcs property és egy navigációs property tartozik a `Product` osztályban és egy navigációs property a `Category`-ban. A többes navigációs property-k legyenek csak olvashatók és a típusuk legyen `ICollection<>`.

T> Általánosságban nem kötelező egy kapcsolat mindkét oldalán navigációs property-t felvenni, de erősen javasolt és mindig jó, ha van. Az entitáson végzendő műveleteket egyszerűsíti, illetve a konvenciós logika is következtet belőle.

Az Order-Product több-többes kapcsolatothoz nem elég egy-egy kollekciót felvenni a két osztályban. Létre kell hozzuk a kapcsolótáblának megfelelő entitást is, ami egy-egy Product és Order közötti kapcsolatot reprezentálja.

    - **ProductOrders** (ProductId:int, OrderId:int)
  
![Product-Order kapcsolótábla](images/efcore-bridgetab.png)

Ezután így néznek ki az entitások (segítség a gépeléshez: bit.ly/dotnetlabor6-7)

<<(code/efcore-category.cs)
<<(code/efcore-order.cs)
<<(code/efcore-product.cs)
<<(code/efcore-productorder.cs)
