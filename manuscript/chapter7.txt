# ASP.NET Core webszolgáltatások I.

## Kiinduló projektek beüzemelése

A kiinduló solution két .NET Standard 2.0 osztálykönyvtárat foglal magába, melyek egy N-rétegű architektúra egy-egy rétegét valósítják meg

- **WebApiLabor.DAL**: lényegében az Entity Framework gyakorlatok anyagát tartalmazza, ez az adatelérési rétegünk.
- **WebApiLabor.Bll**: a DAL rétegre épülő, az üzleti logikát megvalósító szolgáltatásokat tartalmazza. A *Dtos*, *Exceptions* mappák egyelőre nem érdekesek, első körben nem fogjuk még a bennük lévő típusokat használni.

Adjunk hozzá a solution-höz egy új Web projektet (C# → Web → ASP.NET Core Web Application (.NET Core)), a neve legyen *WebApiLabor.API*.

A következő dialógusablakban válasszuk ki az *ASP.NET Core 2.2* opciót és azon belül a API sablont. Más egyéb extrát (HTTPS, Docker, stb.) ne kérjünk. Adjuk hozzá projekt függőségként a *Bll* projektet.

### Adatbázis inicializálása Code-First migrációval

Az EF gyakorlatok alapján megoldható, így itt csak rövidítve ismertetjük.

Hozzunk létre egy új LocalDB adatbázist egy választott névvel, pl. neptun kód, northwind, stb. A `NorthwindContext.OnConfiguring`-ban lévő connection string-ben ennek megfelelően írjuk át az adatbázis nevét.

Fordítsuk a teljes solution-t, állítsuk be indítandó (startup) projektnek az új Web API projektet. A Package Manager Console-t nyissuk meg és ellenőrizzük, állítsuk be Default Project-ként a DAL projektet.

```powershell
Update-Database
```

W> Fontos, hogy a fenti parancs két projektet ismerjen: azt, amelyikben a kontext van, ill. a kontextet használó futtatható projektet. A VS Package Manager Console-jában futtatva alapértelmezésben az előbbit a Default Project értéke adja meg, utóbbit az indítandó projekt. Továbbá ezeket a projekteket meg lehet adni [paraméterként](https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/powershell#common-parameters) is.

Ellenőrizzük, hogy rendben lefutott-e a migráció, létrejöttek-e az adatbázis objektumok, feltöltődtek-e a táblák.

## Az EF kontext és naplózás bekötése az ASP.NET Core DI rendszerébe

Most már van `ConfigureServices` függvényünk (lásd ASP.NET Core bevezető gyakorlatot), regisztráljuk az EF kontextet és az EF naplózó szolgáltatást a DI rendszerbe.

A kontext regisztrálása a `Startup.ConfigureServices` függvénybe:

```csharp
services.AddDbContext<NorthwindContext>(o =>
    o.UseSqlServer(Configuration["ConnectionStrings:DefaultConnection"])
    .ConfigureWarnings(
        c => c.Throw(RelationalEventId.QueryClientEvaluationWarning)));
```

Az EF naplózást az ASP.NET Core naplózó rendszere végzi, amit az alapértelmezett `WebHost` már inicializál, így ezzel kapcsolatban nincs teendőnk. Kommentezzük ki a szükségtelenné vált `GetLoggerFactory`, `OnModelCreating` függvényeket a `NorthwindContext` osztályban. Cserébe egy új konstruktorra lesz szükségünk, ami `DbContextOptions<NorthwindContext>`-et vár.

```csharp
public NorthwindContext(DbContextOptions<NorthwindContext> options)
    : base(options){}
```

Az *appsettings.Development.json*-ba vegyük fel a connection string-et. Átmásolhatjuk a kikommentezett részből vagy az SQL Server Object Explorer-ből.

```javascript
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "System": "Information",
      "Microsoft": "Information"
    }
  },
  //leanpub-start-insert
  "ConnectionStrings": {
    "DefaultConnection": "<connection string>"
  }
  //leanpub-end-insert
}
```

Fordítást követően kipróbálhatjuk az EF működését egy adatbázis újrainicializációval.

```powershell
Update-Database 0
Update-Database
```

T> Itt mutatkozik meg, hogy a migráció lényegében egy teljes alkalmazásindítást jelent a `Startup` osztályon keresztül, inicializálódik a DI konténer, a konfigurációs objektum, stb.

## EF kontext használata a kontroller rétegben

Bár architektúra szempontból nem a legszebb, a BLL réteget gyakorlatilag mellőzve közvetlenül is használhatjuk az EF entitásokat a kontrollerek megvalósításánál.  A *Controllers* mappában hozzunk létre egy kontrollert (Add → Controller... → API Controller with actions using Entity Framework). A felbukkanó ablakban válasszuk ki a `Product` entitás osztályt, a kontextet és adjunk meg nevet ( `EFProductsController`).

W> Figyeljünk rá, hogy ne a `Dto` névtérből adjuk meg a DTO típust a tényleges entitástípus helyett.

A legenerálódó kontroller már használható is. Állítsuk át a zöld nyíl mellett az indítási konfigurációt a projektnevesre, hogy kestrel induljon és így lássuk a konzolon a naplót. Indítsuk a projektet és próbáljuk például lekérni az összes terméket az **api/efproducts** címről.

Figyeljük meg, hogy a controller a konstruktorban igényli meg a DI-tól az EF kontextet, amit a szokásos módon osztályváltozóban tárol el.

## Köztes réteg alkalmazása

A rétegezett arhitektúra elveit követve gyakori eljárás, hogy a controller nem éri el közvetlenül az EF kontextet, hanem csak egy extra rétegen keresztül. A controller projekt így függetleníthető az EF-től.

Ehhez a megoldáshoz készítsünk külön kontroller változatot. A *Controllers* mappába hozzunk létre egy kontrollert (Add → Controller... → API Controller with read/write actions) `ProductsController` néven.

A megoldáshoz a Bll projektben már létezik a `ProductService` osztály, aminek szintén függősége az EF kontext és megvalósítja szükséges CRUD műveleteket. Az EF gyakorlaton tanultakra visszautalva mutassuk be a műveletek implementációját. Függőségeknél előnyösebb, ha interfészekre hivatkozunk, mert tesztelésnél az interfész mögötti implementációt általában egyszerűbb cserélni. Szerencsére az `IProductService` interfész is már rendelkezésünkre áll.

Injektáljunk `IProductService`-t az új kontrollerbe.

```csharp
private readonly IProductService _productService;
public ProductsController(IProductService productService)
{
    _productService = productService;
}
```

Adjuk meg a DI konténernek, hogy hogyan kell egy `IProductService` típusú függőséget létrehozni. A `ConfigureServices` függvénybe:

```csharp
services.AddTransient<IProductService, ProductService>();
```

A függőség injektálás úgy működik, hogy kontrollereket is a központi DI komponens példányosítja, és ilyenkor megvizsgálja a konstruktor paramétereket. Ha a konténerben talál alkalmas beregisztrált osztályt, akkor azt létrehozza és átadja a konstruktornak. Ezt hívjuk konstruktor injektálásnak. Ha a létrehozandó függőségnek is vannak konstruktor paraméterei, akkor azokat is megpróbálja feloldani, így rekurzívan a teljes függőségi objektum hierarchiát le tudja kezelni ( ha abban nincs irányított kör).

A regisztráció során több lehetőségünk is van. Egyrészt nem kötelező interfészt megadni egy osztály beregisztrálásához, az osztályt önmagában is be lehet regisztrálni, ilyenkor a konstruktorban is osztályként kell elkérni a függőségeket.

Háromféle példányosítási stratégiával regisztrálhatjuk be az osztályainkat:

- **Transient**: minden egyes injektálás során új példány jön létre
- **Scoped**: HTTP kérésenként egy példány kerül létrehozásra és a kérésen belül mindenkinek ez lesz injektálva
- **Singleton**: mindenkinek ugyanaz a példány kerül átadásra kéréstől függetlenül

Írjunk új `Get()` változatot az eredeti helyett a `ProductsController`-be az `IProductService` függőséget felhasználva:

```csharp
[HttpGet]
public IEnumerable<Product> Get()
{
    return _productService.GetProducts();
}
```

Próbáljuk ki (*api/products*). A konzolon láthatóan hibát kapunk, mert a `ProductService` lekérdező függvénye eager loading-gal (`Include`) navigációs property-ket is kitölt, így könnyen hivatkozási kör jön létre, amit a JSON sorosító alapértelmezésben kivétellel jutalmaz. A sorosítást az MVC middleware végzi, a kontrollerfüggvény visszatérési értékét sorosítja a HTTP tartalomegyeztetési szabályok szerint. Böngésző kliens esetén alapesetben JSON formátum lesz a befutó. Persze a sorosítás ennél közvetlenebbül is [konfigurálható](https://docs.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting), ha szükséges. A sorosítók beállítását tehát az MVC middleware konfigurációja során adhatjuk meg. Állítsuk be, hogy a sorosító oldja fel a kört úgy, hogy az újból sorosítandó elemet ne sorosítsa, azaz ne zárja be a kört.

```csharp
services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
    //leanpub-start-insert
    .AddJsonOptions(
        json => json.SerializerSettings.ReferenceLoopHandling
                = ReferenceLoopHandling.Ignore);
    //leanpub-end-insert
```

T> Nem csak ezzel a stratégiával oldható fel a körkörös hivatkozás, lásd például [itt](https://stackoverflow.com/a/23461179/472575).

Próbáljuk ki így is az alkalmazást: ugyanannyi terméket kapunk vissza, de az egyes termékekről jóval több adatot.

## REST konvenciók alkalmazása

A REST megközelítés nem csak átviteli közegnek tekinti a HTTP-t, hanem a protokoll részeit felhasználja, hogy kiegészítő információkat vigyen át. Emiatt előnyös lenne, ha nagyobb ellenőrzésünk lenne a HTTP válasz felett, szerencsére az ASP.NET Core biztosítja ehhez a megfelelő API-kat.

Egyik legegyszerűbb ilyen irányelv, hogy a lekérdezések eredményeként, ha megtaláltuk és visszaadtuk a kért adatokat, akkor **200 (OK)** HTTP válaszkódot adjunk. 

T> A HTTP kérést érintő irányelvekről egy jó összefoglaló elérhető [itt](https://www.restapitutorial.com/lessons/httpmethods.html).

Az eddig megírt `Get()` függvényünk most is **200 (OK)**-ot ad, ezt le is ellenőrizhetjük a böngészőnk hálózati monitorozó eszközében.

T> A HTTP kommunikáció megfigyelésére használhatjuk a böngészők beépített eszközeit, minta mailyen a [Firefox Developer Tools](https://developer.mozilla.org/en-US/docs/Tools), illetve [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/). Általában az \[F12\] billentyűvel aktiválhatók. Emellett, ha egy teljesértékű HTTP kliensre van szükségünk, amivel például könnyen tudunk nem csak GET kéréseket küldeni, akkor a [Postman](https://www.getpostman.com/) és a [Fiddler](https://www.telerik.com/download/fiddler) külön telepítendő eszközök ajánlhatók. A Fiddler, mint proxy megoldás, egy Windows gépen folyó HTTP kommunikáció megfigyelésére is alkalmas.

Első körben a két lekérdező függvényt írjuk át úgy, hogy a HTTP válaszkódokat explicit megadjuk. A jelenlegi legmodernebb mód ehhez az `AsyncResult<>` használata. Elég `T`-t visszaadnunk a függvényben, automatikusan `AsyncResult<T>` típussá konvertálódik. Tehát elvileg írhatnánk ezt:

```csharp
//NEM FORDUL!
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _productService.GetProducts();
}
```

Azonban ez nem fordul, mert interfész típus esetén nem működik a konverzió. Konkrét típust, pl. egy listát kell megadnunk.

```csharp
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _productService.GetProducts()
    //leanpub-start-insert
        .ToList();
    //leanpub-end-insert
}
```

T> Ez most nem volt nagy érvágás teljesítményügyileg, a BLL-ben már legyártjuk a listát, csak épp `IEnumerable<>`-ként adjuk át. A fenti `ToList` gyakorlatilag nem csinál semmit.

A másik `Get` függvény még egyszerűbb:

```csharp
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    return _productService.GetProduct(id);
}
```

Próbáljuk ki mindkét függvényt, ellenőrizzük a státuszkódokat is.

Ami fura, hogy még mindig nem állítottunk explicit státuszkódokat. A logikánk most még nagyon egyszerű, csak a hibamentes ágat néztük, így eddig az `ActionResult` alapértelmezései megoldották, hogy **200 (OK)**-ot kapjunk.

Most viszont következzen egy létrehozó művelet:

```csharp
[HttpPost]
public ActionResult<Product> Post([FromBody] Product product)
{
    var created = _productService.InsertProduct(product);
    return CreatedAtAction(nameof(Get), new { id = created.Id }, created);
}
```

Itt már látszik az `ActionResult` haszna. A konvenciónak megfelelően 201-es kódot akarunk visszaadni. Ehhez a `ControllerBase` ősosztály biztosít segédfüggvényt. A segédfüggvény olyan `ActionResult` leszármazottat ad vissza, ami 201-es kódot szolgáltat a kliensnek. Másik konvenció, hogy a *Location* HTTP fejlécben legyen egy URL az új termék lekérdező műveletének meghívásához.

Próbáljuk ki a műveletet Fiddlerben vagy Postman-ben! Egy `Product`-ot kell felküldenünk. JSON formátumú példát találunk a kóddarabkák között. Ne felejtsük el a *Content-Type* fejlécet  application/json-re állítani! Figyeljük meg a kapott választ. A válaszból másoljuk ki a *Location* fejlécből az URL-t és hívjuk meg böngészőből.

A módosító, törlő műveleteknél a konvenció megengedi, hogy üres törzsű (body) választ adjunk, ilyenkor a válaszkód **204 (No Content)**. Ilyesfajta válasz előállításához is van segédfüggvény, illetve elég csak az `IActionResult` interfészt megadni visszatérési típusnak:

```csharp
 [HttpPut("{id}")]
 public IActionResult Put(int id, [FromBody] Product product)
 {
     _productService.UpdateProduct(id, product);
     return NoContent();
 }

 [HttpDelete("{id}")]
 public IActionResult Delete(int id)
 {
     _productService.DeleteProduct(id);
     return NoContent();
 }
```

Próbáljuk kitörölni az újonnan felvett terméket Fiddler/Postman-ből (*DELETE* igés kérés az *api/products/<új id>* címre). Sikerülnie kell, mert még nincs rá idegen kulcs hivatkozás.

A fenti műveletek során csak a hibamentes ágat valósítottuk meg. A többi ágat (hibás kérés, erőforrás nem található stb.) a felesleges boilerplate kódok elkerülése végett majd külön middleware-ekben illetve MVC filterekben valósítjuk meg a későbbiekben.

## DTO osztályok

Közvetlenül az entitástípusok sorosítása láthatóan működik, de nem szerencsés. A modell kifejezetten az EF számára lett megalkotva és hogy a lekérdező műveleteket minél kényelmesebben végezhessük. A kliensoldal számára érdemes külön modellt megalkotni, a DTO (*Data Transfer Object*) modellt, ami a kliensoldal igényeit veszi figyelembe: **pontosan** annyi adatot tartalmaz, amire a kliensnek szüksége van.

A *Bll* projektben jelenleg egy nagyon egyszerű DTO modell található a *Dtos* mappában:

- nincs benne minden navigációs property, pl. `Category.Products`
- nincs benne a kapcsolótáblát reprezentáló entitás
- a termékből közvetlenül elérhetők a megrendelések


MS SQL Server helyett a *LocalDB* nevű fejlesztői adatbázist használjuk, mely fejlesztői szempontból gyakorlatilag megegyezik az MS SQL Server-rel. A LocalDB a Visual Studio-val együtt települ, minden Windows felhasználónak külön LocalDB példány indítható el. A Visual Studio az SQL Server Object Explorer ablak megnyitásakor létrehozza az *MSSQLLocalDB* nevű példányt.

T> A LocalDB külön is letölthető, illetve a vele együtt települő *sqllocaldb* parancs segítségével egyszerűen kezelhető. Minderről bővebb információ a dokumentációban [olvasható](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-2016-express-localdb).

Az automatikusan létrejövő MSSQLLocalDB nevű LocalDB példány connection stringjét adjuk meg, pontosabban az *SQL Server Object Explorer* ablak segítésével másoljuk ki: *(localdb)\MSSQLLocalDB* szerveren jobbklikk → Properties → Connection String. A kimásolt stringben az *Initial Catalog* értékét (a DB nevét) a **master**-ről változtassuk meg valamilyen más névre, például a neptun kódunkra.

![Connection string megszerzése az SQL Server Object Explorer-ből](images/efcore-ssoe.png)

T> Mivel a connection string-ben különleges karakterek (pl. '\\') vannak, ne felejtsük el a @-ot a string elé írni!

```csharp
public class NorthwindContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@"<connstring>");
    }

    public DbSet<Product> Products { get; set; }
    public DbSet<Category> Categories { get; set; }
    public DbSet<Order> Orders { get; set; }
}
```

T> A nagyobb rugalmasság érdekében érdemes a connection stringet konfigurációs fájlba helyezni, és egy saját `IDbContextFactory` implementációval, vagy az ASP.NET konfigurációs megoldásaival felolvasni. Erre egy későbbi gyakorlaton nézünk példát.

Az első verziós DAL rétegünk ezzel kész is van.

## Sémamódosítás

### Code-First Migrations

A kódban történő sémamódosításokat követni tudja a keretrendszer, és a változások alapján frissíteni tudja az adatbázis sémáját lefele, illetve felfele irányban is. Ezt a mechanizmust nevezzük migrációnak. Esetünkben a séma nulláról felhúzása is már módosításnak számít.

A migráció elvégzésére parancssoros utasításokat kell igénybe vennünk. Itt kétfajta megközelítés is adott: vannak PowerShell és vannak klasszikus cmd (dotnet cli) parancsaink.
Fel kell telepítsük a projektünkbe valamelyik NuGet csomagot:

- **Powershell**: Microsoft.EntityFrameworkCore.Tools (telepítsük fel most ezt)
- **Parancssor**: Microsoft.EntityFrameworkCore.Tools.DotNet

Hozzuk elő a **Package Manager Console**-t. (Tools → Library Package Manager). Ellenőrizzük, hogy a *Default Project* legördülőben a mi projektünk van-e kiválasztva. Az `Add-Migration <név>` paranccsal tudunk készíteni egy új migrációs lépést, így az első migrációnk a kiinduló sémánk migrációját fogja tartalmazni.

```powershell
Add-Migration Init
```

Figyeljük meg mit generált a projektünkbe ez a parancs. Itt a migrációhoz egy osztályt készít, ami tartalmazza azokat az utasításokat, amikkel fel- vagy le tudjuk frissíteni az adatbázis sémánkat. Fontos, hogy lefordítsuk a projektet, mert ezen és a többi kódunk alapján fog futni a migráció.

Fordítás után adjuk ki az `Update-Database` parancsot, amivel egy adott migrációs állapotig próbálja frissíteni a sémát. Ha nem adunk meg sémanevet akkor a legfrissebb migrációig frissít:

```powershell
Update-Database Init
```

Ellenőrizzük le az adatbázis sémáját az *SQL Server Object Explorer* ablakban. Mutassuk meg, hogy pusztán konvenciók alapján milyen tulajdonságokat talált ki az EF.

T> Kódból is legenerálhatnánk az adatbázist az aktuális sémával a `DbContext.Database.EnsureCreated` metódus segítségével, viszont ez a későbbiekben megnehezíti a további sémamódosítást, mivel mindig el kellene dobjuk az adatbázist, illetve a migrációt sem könnyű utólag bevezetni.

## Mapping és egyéb mataadatok megadása II. – fluent és attribute mapping konfiguráció

Definiáljuk felül a kontext-ünkben az ős `OnModelCreating` metódusát és itt állítsunk be pár mapping információt.

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    modelBuilder.Entity<Category>()
        .Property(c => c.Name)
        .HasMaxLength(15)
        .IsRequired();
}
```

Ezzel a `Name` property hosszát állítottuk be és megadtuk, hogy kötelező (nem `NULL`-ozató) mező.

A fluent mellett próbáljuk ki az attribútumos konfigurációt is. Állítsuk át az alapértelmezett táblanevet a `Product` osztály esetében a `Table` attribútummal.

```csharp
[Table("PRODUCT")]
public class Product
{
    // ...
}
```

T> Érdemes megfigyelni a táblanevek kapcsán, hogy eleve többesszámosított neveket találunk az adatbázisban. Ezt az `IPluralizer` service végzi, melyhez saját implementáció is írható.

Mivel már létezik az adatbázisunk migráció segítségével kell frissítsük az adatbázis sémáját. Készítsünk egy új migrációs lépést az `Add-Migration` utasítással és frissítsük a sémát az `Update-Database` paranccsal.

T>Ha van időnk megnézhetjük az adatbázison futtatott SQL-t is a Script-Migration paranccsal. Például ez mutatja a legutóbbi módosítást érvényesítő SQL-t: `Script-Migration -From Init`

```powershell
Add-Migration CategoryName_ProductTableName
Update-Database CategoryName_ProductTableName
```

T> Természetesen mivel még nincsenek adataink az adatbázisban akár el is dobhatnánk az adatbázist és újra legenerálhatnánk nulláról a sémát, de most kifejezetten a migrációt szeretnénk gyakorolni. Az `Add-Migration` kimenete figyelmeztet, hogy adatvesztés is történhet. Vannak veszélyes migrációs műveletek, ezért érdemes átnézni a generálódó migrációs kódot.

Nézzük meg milyen migrációs osztályt generáltunk, és hogy ez milyen utasításokat tartalmaz.

Ellenőrizzük, hogy a Name oszlop most már az új kényszereknek megfelelően lett-e felvéve, és hogy a termékek tábla megfelelő néven jelenik-e meg. Ezzel kész a DAL rétegünk konfigurációja.

## Adatbázis naplózás

A következő feladat könnyebb követhetősége érdekében állítsuk be a naplózást az Entity Framework kapcsán.

Az Entity Framework Core az ASP.NET Core-ban is megismert naplózó mechanizmusra épül rá az `ILoggerFactory` interfészen keresztül. Mi most a konzolon keresztül szeretnénk figyelni az éppen végrehajtott SQL utasításokat. Mivel a mi konzolos alkalmazásunkban nincs `Startup` osztály, így naplózást a `DbContext` `OnConfiguring` metódusában kell beállítanunk egy konzolos providert tartalmazó logger factory-ra. Ehhez a `Microsoft.Extensions.Logging.Console` NuGet csomagot kell a projektünkhöz adni.

```csharp
//kóddarabka
private ILoggerFactory GetLoggerFactory()
{
  IServiceCollection serviceCollection = new ServiceCollection();
  serviceCollection.AddLogging(builder => builder.AddConsole());
  return serviceCollection.BuildServiceProvider()
          .GetService<ILoggerFactory>();
}

protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer(_connStr)
    //leanpub-start-insert
        .UseLoggerFactory(GetLoggerFactory());
    //leanpub-end-insert
}
```

W> Ez az eljárás 2.2 specifikus! 3.0-ban és 2.2 előtt is más API volt/lesz az ajánlott!

T> Ha nem a konzolt szeretnénk teleszemetelni, akkor akár a Debug outputra is írhatunk. Ehhez a *Microsoft.Extensions.Logging.Debug* csomagban található `AddDebug` metódust kell használjuk.

## Adatbázisműveletek

### Beszúrás

Írjunk egy egyszerű beszúró kódot a `Program` osztályba. Várjunk paraméterül egy kontext-et, és csak akkor szúrjunk be az adatbázisba bármit, ha még üres.

```csharp
using System.Linq;

static void SeedDatabase(NorthwindContext ctx)
{
    if (!ctx.Products.Any())
    {
        var cat_drink = new Category { Name = "Ital" };
         var cat_food = new Category { Name = "Étel" };
        ctx.Categories.Add(cat_drink);
        ctx.Categories.Add(cat_food);
        ctx.Products.Add(new Product
                     { Name = "Sör", UnitPrice = 50, Category = cat_drink });
        ctx.Products.Add(new Product
                    { Name = "Bor", Category = cat_drink });
        ctx.Products.Add(new Product
                    { Name = "Tej", CategoryId = cat_drink.Id });
        ctx.SaveChanges();
    }
}
```

Figyeljük meg, hogy milyen egyszerű bánni a kapcsolódó elemekkel. (Hivatkozhatunk rájuk ID-val vagy referenciával) Az ID-s hivatkozást is szépen le tudja kezelni azáltal, hogy a még nem perzisztált, újonnan hozzáadott objektumok egyedi negatív azonosítót kapnak, amikor hozzáadjuk őket valamelyik `DbSet`-hez. Persze érdemes körültekintően eljárni itt is, lásd a szakasz végén lévő hibára futó kódrészletet.

Hívjuk meg a `Main` függvényben és próbáljuk meg lekérdezni az első terméket. Rakjunk a `Main` végére egy `Console.ReadKey`-t, hogy legyen időnk megnézni a naplót.

```csharp
static void Main(string[] args)
{
    //leanpub-start-insert
    using (var ctx = new NorthwindContext())
    {
        SeedDatabase(ctx);

        var p = ctx.Products.FirstOrDefault();
    }
    Console.ReadKey();
    //leanpub-end-insert
}
```

Próbáljuk ki! Nézzük meg a konzolon az SQL utasításokat. Mutassuk meg a változásokat az adatbázisban. Paraméterezett `INSERT` utasításokat használ az EF, így elkerülve az SQL injection támadást.

Ha a kategória objektumok referenciái semmilyen módon nem kerülnek be a kontextusba mielőtt az ID-s hivatkozást beállítanánk, akkor a hivatkozás 0 értékű lesz. Például az alábbi változat is hibára fut, mert nullás `CategoryID`-ra hivatkozunk, ami nem létezik (ez eddigi változatot kommentezzük ki):

```csharp
//kóddarabka
static void SeedDatabase(NorthwindContext ctx)
{
    var cat_drink = new Category { Name = "Ital2" };
    var sör2 = new Product
    {
        Name = "Sör2", UnitPrice = 50, CategoryId = cat_drink.Id
    };
    ctx.Products.Add(sör2);
    ctx.Categories.Add(cat_drink);
    ctx.SaveChanges();
}
```

T> Figyeljük meg, hogy a konzol naplóban, hogy a `Category` beszúrása még megtörténik, de a `Product` hozzáadása már elszáll. A debuggerrel, ha megállunk a `SaveChanges` híváson, akkor látható, hogy a `CategoryId` értéke nulla.

Kétféleképpen is javíthatjuk a kódot: a `CategoryId` beállítása előtt hozzáadjuk az új kategóriát a kontextushoz, vagy a navigációs property-t töltjük a `CategoryId` helyett. A harmadik változatunk az utóbbi módszert követi (ez eddigi változatot kommentezzük ki):

```csharp
//kóddarabka
static void SeedDatabase(NorthwindContext ctx)
{
    var cat_drink = new Category { Name = "Ital2" };
    var sör2 = new Product
    {
         Name = "Sör2", UnitPrice = 50, Category = cat_drink
    };
    ctx.Products.Add(sör2);
    ctx.Categories.Add(cat_drink);
    ctx.SaveChanges();
}
```

Ennek már le kell futnia, sikeresek a beszúrások.

### Ősfeltöltés (seeding) elvárt adattartalom megadásával

A kontextuskonfiguráció részeként megadhatjuk, hogy milyen adattartalmat szeretnénk az egyes táblákban látni. A kontext `OnModelCreating` függvényének végére:

```csharp
modelBuilder.Entity<Category>().HasData(
        new Category {Id = 1, Name = "Ital"}
);

//kóddarabka
modelBuilder.Entity<Product>().HasData(
    new Product { Id=1, Name = "Sör", UnitPrice = 50, CategoryId = 1 },
    new Product { Id=2, Name = "Bor", UnitPrice = 550, CategoryId = 1 },
    new Product { Id=3, Name = "Tej", UnitPrice = 260, CategoryId = 1 }
);
```

Fontos, hogy ezen módszer esetén mindenképp kézzel meg kell adnunk az elsődleges kulcs értékeket. Fordítás után generáltassunk új migrációt és frissítsük is az adatbázist - ez utóbbi hibára fog futni:

```powershell
Add-Migration Seed
Update-Database
```

A `HasData` alapján generált migrációs kód nem veszi figyelembe az időközben bekerült adatokat, csak a modellt és a többi migrációt nézi. Ha megnézzük a generált kódot, láthatjuk, hogy csak sima beszúrások. Mivel mi közben jól összeszemeteltük az adatbázist, a migráció által kiadott beszúró műveletek jó eséllyel hibára futnak.

Ha szeretnénk tiszta lappal indulni, bármikor kipucolhatjuk az adatbázist a speciális nullás migrációra való frissítéssel, majd újrahúzhatjuk a `HasData`-nak köszönhetően kezdeti adatokkal ősfeltöltve.

```powershell
Update-Database 0
Update-Database
```

Ezek után a `SeedDatabase` hívásra nincs szükség, kommentezzük ki a `Main` függvényben.

## Lekérdezések

Minden rész után az előző szakasz kódját kommentezzük ki, hogy ne keltsen felesleges zajt a kimeneten az előző utasítás, illetve ne legyenek felesleges mellékhatások.

Kérdezzük le azokat a termékeket, melyeknek neve egy adott betűt tartalmaz. A `Main` függvény `using` blokkjába:

```csharp
//SeedDatabase(ctx);
//var p = ctx.Products.FirstOrDefault();

//leanpub-start-insert
var q = from p in ctx.Products
        where p.Name.Contains("ö")
        select p.Name;

foreach (var name in q)
{
    Console.WriteLine(name);
}
//leanpub-end-insert
```

 A debuggerrel léptessük át az egyes utasításokon a program futását. A késleltetett kiértékelés miatt csak a `foreach` végrehajtása közben fog az adatbázishoz fordulni az EF. Nézzük meg a lefuttatott SQL-t is. Sikerült az `IQueryable<>`-ben található `Expression`-t SQL utasítássá alakítania.

 Az EF elég sok C# függvényt SQL-lé tud fordítani. Példaképp alakítsuk a visszaadott nevet nagybetűssé.

```csharp
var q = from p in ctx.Products
       where p.Name.Contains("ö")
       select p.Name
//leanpub-start-insert
            .ToUpper();
//leanpub-end-insert
```

Figyeljük meg a konzolon a generált SQL-t: a projekciós részbe bekerült az `UPPER` SQL függvény.

### Vegyes kiértékelés

A fák sem nőnek az égig, az EF sem tud minden C# függvényt SQL-lé fordítani. Próbáljuk ki úgy, hogy a `Contains`-t karakterrel hívjuk meg a szűrésben.

```csharp
var q = from p in ctx.Products
       where p.Name.Contains('ö')
       select p.Name;
```

Figyeljük meg, hogy a futtatott lekérdezés itt nem tartalmazza a feltételünket. A teljes táblát lekérdezte az EF és memóriában futtatta le azokat a részeket, amit nem tudott SQL utasítássá fordítani (jelen esetben a karakterrel paraméterezett `Contains`-t) - ez az ún. *Mixed Query Evaluation*. Sőt figyelmeztetést (warning) is kaptunk ezzel kapcsolatban, mivel a lekérdezés hatékonysága jelentősen romlott ezzel.

Milyen jó lenne, ha ezt a kellemetlen helyzetet az EF kivétel formájában közölné velünk, így a későbbiekben egy kevésbé tapasztalt fejlesztő nem kérdezi le feleslegesen a teljes táblát. Ehhez állítsuk át ezt a kontext beállításaiban az alábbi opciót:

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer(_connStr)
        .UseLoggerFactory(GetLoggerFactory())
        //leanpub-start-insert
        .ConfigureWarnings(
            c => c.Throw(RelationalEventId.QueryClientEvaluationWarning)
        );
        //leanpub-end-insert
}
```

Próbáljuk ki, hogy tényleg kivétel keletkezik-e.

T> Persze egy tapasztalatlanabb fejlesztő bevethet egy szőnyeg alá söprő trükköt, és még a `where` feltétel előtt a `Products` `DbSet`-re `ToList`-et hív. A lekérdezés a `ToList` hívása során fut le, és a további `select` és `where` műveletek már mindenképpen a memóriában történnek meg.

W> Különösen fontos, hogy lehetőleg minden EF lekérdezésünket ellenőrizzük le, hogy minden része ott fut-e le (adatbázisban vagy memóriában), ahol számítunk rá. A kódra ránézve ez nem mindig látszik egyértelműen.

## Lekérdezések összefűzése és címkézése

Kérdezzük le egy bizonyos árnál drágább, bizonyos betűt a nevükben tartalmazó termékek nevét - mindezt két külön lekérdezésben:

```csharp
var q = from p in ctx.Products.TagWith("Névszűrés")
        where p.Name.Contains("r")
        select p;

var q2 = from p in q
         where p.UnitPrice > 20
         select p.Name;

foreach (var name in q2)
{
    Console.WriteLine(name);
}
```

A `TagWith` használatával könnyebben megtalálhatjuk a lekérdezés által generált SQL utasítást a naplóban: a függvénynek megadott szöveg közvetlenül a generált utasítás elé kerül.

Ismét figyeljük meg a naplóban, mikor fut le és milyen lekérdezés. Itt is látszik a késleltetett kiértékelés és a lekérdezések össze lesznek fűzve, egy lekérdezés hajtódik végre.

T> Ez rámutat az EF egy nagy előnyére, bonyolult lekérdezéseket megírhatunk kisebb, egyszerűbb részletekben írhatunk meg, az EF pedig összevonja, sőt optimalizálhatja is a lekérdezést.

Próbáljuk ki, `var q =` helyett `IEnumerable<Product> q=`-val is, ilyenkor nem fűzi össze a lekérdezést. A `q2` műveletei már memóriában fognak lefutni, hiszen a `q2` adatforrásként csak egy `IEnumerable`-t lát.

Próbáljuk ki, `var q` = helyett `IQueryable<Product> q=` -val is, ilyenkor megint összefűzi a lekérdezést.

T> Nem lehet elégszer hangsúlyozni az `IQueryable` és az `IEnumerable` közti különbségeket. Az `IQueryable` kifejezések SQL-é fordulnak (amikor letudnak), míg az IEnumerable-en végzett műveletek minden esetben memóriában hajtódnak végre.

T> Ha nem akarunk véletlenül memóriabeli kiértékelésre váltani, az implicit típus (`var`) alkalmazása jó szolgáltat tehet,

## Beszúrás több-többes kapcsolatba

Azokat a termékeket szeretnénk megrendelni, amiknek a nevében van „r”. Használjuk fel újra az előző, hasonló lekérdezésünket.

```csharp
var q = from p in ctx.Products
        where p.Name.Contains("r")
        select p;

var order = new Order { OrderDate = DateTime.Now };
foreach (var p in q)
{
    order.ProductOrders.Add(
        new ProductOrder { Product = p, Order = order }
    );
}

ctx.Orders.Add(order);
ctx.SaveChanges();
```

Ismét figyeljük, hogy milyen SQL generálódik. Az `Order` létrehozása után nekünk még egy új `ProductOrder` entitást is létre kell hoznunk, amit a több-több kapcsolatra használunk fel. Figyeljük meg, hogy minden `Order` hozzáadásával `ProductOrder` is bekerült a kontextusba, majd el is mentődött az adatbázisba.

### Kapcsolódó entitások betöltése

Írjuk ki minden termék neve mellé a kategóriáját is.

```csharp
var products = ctx.Products;

foreach (Product p in products)
{
    Console.WriteLine($"{p.Name} ({p.Category.Name})");
}
```

Figyeljük meg, hogy a fenti lekérdezésben a kategória navigációs property `null` értékű és kivétel is keletkezik, pedig biztosan tartozik a termékhez kategória az adatbázisban. Ennek oka, hogy az EF alapból nem tölti be a navigációs property-k értékeit, ezt egy külön `Include` metódushívással tudjuk megtenni az `IQueryable` típuson. Ez az ún. *eager loading*.

```csharp
using Microsoft.EntityFrameworkCore;

var products = ctx.Products
        //leanpub-start-insert
            .Include(p => p.Category);
        //leanpub-end-insert
```

Ismét figyeljük, hogy mikor mi fut le az adatbázisszerveren: ez egy `JOIN` segítségével egy füst alatt beránt minden adatot mindkét táblából.

Ha a kapcsolódó `Order` listát is szeretnénk kitöltetni, akkor ott egyrészt a `ProductOrders` listát is be kell `Include`-olni, másrészt pedig még egy szinttel lejjebb a `ProductOrder` `Order` tulajdonságát is ki be kell töltetni. Az ilyen többszintes hivatkozást az `Include` és `ThenInclude` használatával lehet elérni:

```csharp
var products = ctx.Products
    .Include(p => p.Category)
    .Include(p => p.ProductOrders)
    //leanpub-start-insert
        .ThenInclude(po => po.Order);
    //leanpub-end-insert

foreach (var p in products)
{
    Console.WriteLine($"{p.Name} ({p.Category.Name})");
    //leanpub-start-insert
    foreach (var po in p.ProductOrders)
    {
        Console.WriteLine($"\tRendelés: {po.Order.OrderDate}");
    }
    //leanpub-end-insert
}
```

Ha nem akarunk minden oszlopot lekérdezni az összes érintett táblából, akkor a select részt úgy is megírhatjuk, hogy csak a szükséges adatokat kérdezze le, ez az ún. *query result shaping*.

```csharp
var products = ctx.Products.Select(p=> new
    {
        ProductName=p.Name,
        CategoryName=p.Category.Name,
        OrderDates= p.ProductOrders
                     .Select(po=>po.Order.OrderDate)
                     .ToArray()
    }
);

foreach (var p in products)
{
    Console.WriteLine($"{p.ProductName} ({p.CategoryName})");
    foreach (var po in p.OrderDates)
    {
        Console.WriteLine($"\tRendelés: {po}");
    }
}
```

T> Az utóbbi két változat több lekérdezést generál egy darab többtáblás `JOIN` helyett. Az EF attól függően generálhat egy vagy több lekérdezést, hogy egy kapcsolatot milyen irányból navigálunk. Ez egy [vitatott](https://github.com/aspnet/EntityFrameworkCore/issues/12098) működés, előreláthatólag a 3.0-ás verzióban változik a helyzet.

### Módosítás, Find

Nézzünk példát egyszerű módosításra.

```csharp
var pFirst = ctx.Products.Find(1);
Console.WriteLine(ctx.Entry(pFirst).State);
pFirst.UnitPrice *= 2;
Console.WriteLine(ctx.Entry(pFirst).State);
ctx.SaveChanges();
Console.WriteLine(ctx.Entry(pFirst).State);
```

Mutassuk be az EF change tracking működését. A lekérdezések eredménye alapértelmezetten bekerül a változáskövetőbe (change tracker). Figyeljük meg, hogyan kezeli az EF a hozzá tartozó objektumok állapotát.

A `Find` az elsődleges kulcs alapján keres ki egy entitást. Nem kell ismernünk az elsődleges kulcs property nevét. Ha a változáskövetőbe már korábban bekerült a keresett entitás, akkor onnan kapjuk vissza, ilyenkor adatbázishozzáférés nem történik.

### Törlés

Töröljük ki az adatbázisból az előbb létrehozott megrendelések közül az egyiket.

```csharp
var orderToRemove =
    (
      from p in ctx.Orders
      select p
    ).First();

ctx.Orders.Remove(orderToRemove);
ctx.SaveChanges();
```

Figyeljük meg az adatbázis adatai között, hogy az `Order` törlésével a `ProductOrder` kapcsolódó bejegyzés is törlődött, mivel alapértelmezetten a sémán be van kapcsolva a kaszkád törlés. Ez ebben az esetben indokolt is lenne, de sokszor nem szeretnénk, ha a kapcsolódó rekordok is törlődnének. Ennek megakadályozására vegyük fel explicit a konfigurációban az `Order–ProductOrder` kapcsolatot és kapcsoljuk ki rajta a kaszkád törlést az `OnModelCreating`-ben.

```csharp
modelBuilder.Entity<Order>()
    .HasMany(o => o.ProductOrders)
    .WithOne(po => po.Order)
    .OnDelete(DeleteBehavior.Restrict);
```

A törölt `Order`-t és a szükséges kapcsoló rekordokat vegyük fel migráció által beszúrt adatként.

```csharp
//kóddarabka
modelBuilder.Entity<Order>().HasData(
     new Order {Id = 1, OrderDate = new DateTime(2019, 02, 01)}
);

modelBuilder.Entity<ProductOrder>().HasData(
    new ProductOrder { Id = 1, OrderId = 1, ProductId = 1},
    new ProductOrder { Id = 2, OrderId = 1, ProductId = 2 }
);
```

Fordítás után ne felejtsük el migrációval átvezetni az adatbázis sémájába is a változásokat.

```powershell
Add-Migration ProductOrderRestrictDelete
Update-Database 0
Update-Database
```

Szúrjuk be újra a megrendelést, majd próbáljuk meg újra törölni azt. A törlés során kivételt kapunk, mivel a `ProductOrder` rekord nem törlődött kaszkád módon, így az egy már nem létező `Order`-re hivatkozik, viszont ez a külső kulcs kényszert megsérti. Emiatt az egész törlési művelet meghiúsul.

T> Adatkezelő alkalmazásokban az adatbázisbeli törlés (SQL `DELETE` utasítás) helyett inkább logikai törlést alkalmaznak. A logikai törlés megvalósításával ezen gyakorlat keretében nem foglalkozunk.

## Egyéb funkciók

### Felsorolt típus, értékkonvertálók

Az EF alapértelmezetten képes a felsorolt típusokat is leképezni. Hozzunk létre új felsorolt típust a `Product` osztály mellé ShipmentRegion néven.

```csharp
//kóddarabka
[Flags]
public enum ShipmentRegion
{
    EU = 1,
    NorthAmerica = 2,
    Asia = 4,
    Australia = 8
}
```

A `Flags` attribútummal azt jelezzük, hogy szeretnék a bitműveleteket is alkalmazni a felsorolt értékére, így egy `ShipmentRegion` típusú változó egyszerre több értéket is felvehet (pl.: 3-as érték egyszerre tartalmazza az EU-t és Észak-Amerikát is).

Vegyünk fel a `Product` osztályba egy új property-t az új felsorolt típussal.

```csharp
public ShipmentRegion ShipmentRegion { get; set; }
```

Módosítsuk és bővítsük a kezdeti `Product`-ok listáját szállítási információkkal:

```csharp
//kóddarabka
modelBuilder.Entity<Product>().HasData(
    new Product
    {
         Id =1, Name = "Sör", UnitPrice = 50, CategoryId = 1,
        //leanpub-start-insert
         ShipmentRegion = ShipmentRegion.Asia
        //leanpub-end-insert
    },
    new Product { Id=2, Name = "Bor", UnitPrice = 550, CategoryId = 1 },
    new Product { Id=3, Name = "Tej", UnitPrice = 260, CategoryId = 1 },
    //leanpub-start-insert
    new Product
    {
        Id = 4, Name = "Whiskey", UnitPrice = 960, CategoryId = 1,
        ShipmentRegion = ShipmentRegion.Australia
    },
    new Product
    {
        Id = 5, Name = "Whiskey", UnitPrice = 960, CategoryId = 1,
        ShipmentRegion = ShipmentRegion.EU | ShipmentRegion.NorthAmerica
    }
     //leanpub-end-insert
  );
```

Figyeljük meg a generált migrációban, hogy milyen ügyesen lekezeli az EF a korábbi migrációban beszúrt elem (1-es `Id`) változását, módosító kódot generál hozzá.

Változott a modell, frissítsük az adatbázist.

```powershell
Add-Migration ProductShipmentRegion
Update-Database
```

Figyeljük meg, hogy az új oszlop egész számként tárolja a felsorolt típus értékeit. Ha ez nem tetszik nekünk, használhatjuk az értékkonvertálókat (*value converter*), melyek az adatbázis- és az objektummodell között képesek oda-vissza konvertálni a leképezett elemek értékeit. Számos beépített konvertáló van az EF-ben. Az `enum`-`string` átalakítót használva érjük el, hogy szövegként jelenjenek meg a szállítási területek az adatbázisban. Az `OnModelCreating`-be:

```csharp
var converter = new EnumToStringConverter<ShipmentRegion>();
modelBuilder
    .Entity<Product>()
    .Property(e => e.ShipmentRegion)
    .HasConversion(converter);
```

T> A konvertereket érdemes lehet külön létrehozni, mert nyugodtan újrahasználhatjuk őket, nem kell mindig új példány.

Változott a modell, frissítsük az adatbázist.

```powershell
Add-Migration ProductShipmentRegion
Update-Database
```

Ellenőrizzük a termékek táblájában, hogy sikerült-e az átalakítás. Kipróbálhatjuk, hogy működik-e a konverzió objektummodell szinten is. A `Main` függvényben kérjük el az összes terméket:

```csharp
var prods = ctx.Products.ToArray();
```

Vizsgáljuk meg a tömbben lévő termékeket debuggerrel: látható, hogy a szállítási területek megfelelő értékűek.

T> Saját konvertereket is írhatunk, ha a beépítettek között nem találunk megfelelőt.

### Tranzakciók

Az EF az egyes SaveChanges hívásokat egy tranzakcióban futtatja (ha az adatbázis provider támogatja azt). Viszont gyakran megesik az, hogy több `SaveChanges` hívást kellene egy tranzakcióban kezelnünk. Tehát ha az egyik sikertelenül fut le, akkor a többit sem szabad érvényre juttatni.

Nézzünk példát a tranzakciókezelésre. Szúrjunk be több terméket az adatbázisba több `SaveChanges` hívással.

```csharp
try
{
    using (var transaction = ctx.Database.BeginTransaction())
    {
        ctx.Products.Add(new Product()
        {
            Name = "Coca Cola",
            CategoryId = 1,
        });
        ctx.SaveChanges();
        ctx.Products.Add(new Product()
        {
            Name = "Pepsi",
            CategoryId = 2,
        });
        ctx.SaveChanges();
        transaction.Commit();
    }
}
catch (Exception e){}
```

A tranzakciók kezdete-végével kapcsolatos események csak a debug szintű naplóban jelennek meg. Állítsuk át a naplózási szintet a `NorthwindContext.GetLoggerFactory` függvényben:

```csharp
IServiceCollection serviceCollection = new ServiceCollection();
serviceCollection.AddLogging(builder => builder.AddConsole()
    //leanpub-start-insert
                             .AddFilter(ll => ll == LogLevel.Debug));
    //leanpub-end-insert
```

A tranzakción `Commit`-ot hívunk, ha sikeresen lefutott mindegyik `SaveChanges`, ha valamelyik hibára futott, akkor a using blokkból való kilépésig nem fog `Commit` hívódni. Ha bármilyen ok miatt a `Commit` nem hívódik meg, legkésőbb a using blokk vége `Rollback`-el **lezárja a tranzakciót**.

Próbáljuk ki! Ezesetben helyesen fut le a beszúrásunk. Figyeljük meg a konzolon a tranzakciókezeléssel kapcsolatos üzeneteket.

Teszteljük a hibás ágat is azáltal, hogy a második terméket egy nem létező kategóriába próbáljuk meg beszúrni.

```csharp
ctx.Products.Add(new Product()
{
    Name = "Rum",
    //leanpub-start-insert
    CategoryId = 100,
    //leanpub-end-insert
});
```

Figyeljük meg, hogy ilyenkor nem kerül beszúrásra az első termék sem. Megint csak figyeljük meg a konzolon a tranzakciókezeléssel kapcsolatos üzeneteket.