# ASP.NET Core webszolgáltatások I.

## Kiegészítő anyagok, segédeszközök

- kóddarabka fájl: aspnetcorerest.md
- kiinduló solution: https://github.com/bmeaut/WebApiLab2019/tree/init
  - elég csak zip-ként letölteni, nem kell klónozni
  - figyeljünk rá, hogy az *init* ágat töltsük le
- Fiddler vagy Postman HTTP kérések küldéséhez

## Kiinduló projektek beüzemelése

A kiinduló solution két .NET Standard 2.0 osztálykönyvtárat foglal magába, melyek egy N-rétegű architektúra egy-egy rétegét valósítják meg

- **WebApiLabor.DAL**: lényegében az Entity Framework gyakorlatok anyagát tartalmazza, ez az adatelérési rétegünk.
- **WebApiLabor.Bll**: a DAL rétegre épülő, az üzleti logikát megvalósító szolgáltatásokat tartalmazza. A *Dtos*, *Exceptions* mappák egyelőre nem érdekesek, első körben nem fogjuk még a bennük lévő típusokat használni.

Adjunk hozzá a solution-höz egy új Web projektet (C# → Web → ASP.NET Core Web Application (.NET Core)), a neve legyen *WebApiLabor.API*.

A következő dialógusablakban válasszuk ki az *ASP.NET Core 2.2* opciót és azon belül a API sablont. Más egyéb extrát (HTTPS, Docker, stb.) ne kérjünk. Adjuk hozzá projekt függőségként a *Bll* projektet.

### Adatbázis inicializálása Code-First migrációval

Az EF gyakorlatok alapján megoldható, így itt csak rövidítve ismertetjük.

Hozzunk létre egy új LocalDB adatbázist egy választott névvel, pl. neptun kód, northwind, stb. A `NorthwindContext.OnConfiguring`-ban lévő connection string-ben ennek megfelelően írjuk át az adatbázis nevét.

Fordítsuk a teljes solution-t, állítsuk be indítandó (startup) projektnek az új Web API projektet. A Package Manager Console-t nyissuk meg és ellenőrizzük, állítsuk be Default Project-ként a DAL projektet.

```powershell
Update-Database
```

W> Fontos, hogy a fenti parancs két projektet ismerjen: azt, amelyikben a kontext van, ill. a kontextet használó futtatható projektet. A VS Package Manager Console-jában futtatva alapértelmezésben az előbbit a Default Project értéke adja meg, utóbbit az indítandó projekt. Továbbá ezeket a projekteket meg lehet adni [paraméterként](https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/powershell#common-parameters) is.

Ellenőrizzük, hogy rendben lefutott-e a migráció, létrejöttek-e az adatbázis objektumok, feltöltődtek-e a táblák.

## Az EF kontext és naplózás bekötése az ASP.NET Core DI rendszerébe

Most már van `ConfigureServices` függvényünk (lásd ASP.NET Core bevezető gyakorlatot), regisztráljuk az EF kontextet és az EF naplózó szolgáltatást a DI rendszerbe.

A kontext regisztrálása a `Startup.ConfigureServices` függvénybe:

```csharp
services.AddDbContext<NorthwindContext>(o =>
    o.UseSqlServer(Configuration["ConnectionStrings:DefaultConnection"])
    .ConfigureWarnings(
        c => c.Throw(RelationalEventId.QueryClientEvaluationWarning)));
```

Az EF naplózást az ASP.NET Core naplózó rendszere végzi, amit az alapértelmezett `WebHost` már inicializál, így ezzel kapcsolatban nincs teendőnk. Kommentezzük ki a szükségtelenné vált `GetLoggerFactory`, `OnModelCreating` függvényeket a `NorthwindContext` osztályban. Cserébe egy új konstruktorra lesz szükségünk, ami `DbContextOptions<NorthwindContext>`-et vár.

```csharp
public NorthwindContext(DbContextOptions<NorthwindContext> options)
    : base(options){}
```

Az *appsettings.Development.json*-ba vegyük fel a connection string-et. Átmásolhatjuk a kikommentezett részből vagy az SQL Server Object Explorer-ből.

```javascript
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "System": "Information",
      "Microsoft": "Information"
    }
  },
  //leanpub-start-insert
  "ConnectionStrings": {
    "DefaultConnection": "<connection string>"
  }
  //leanpub-end-insert
}
```

Fordítást követően kipróbálhatjuk az EF működését egy adatbázis újrainicializációval.

```powershell
Update-Database 0
Update-Database
```

T> Itt mutatkozik meg, hogy a migráció lényegében egy teljes alkalmazásindítást jelent a `Startup` osztályon keresztül, inicializálódik a DI konténer, a konfigurációs objektum, stb.

## EF kontext használata a kontroller rétegben

Bár architektúra szempontból nem a legszebb, a BLL réteget gyakorlatilag mellőzve közvetlenül is használhatjuk az EF entitásokat a kontrollerek megvalósításánál.  A *Controllers* mappában hozzunk létre egy kontrollert (Add → Controller... → API Controller with actions using Entity Framework). A felbukkanó ablakban válasszuk ki a `Product` entitás osztályt, a kontextet és adjunk meg nevet ( `EFProductsController`).

W> Figyeljünk rá, hogy ne a `Dto` névtérből adjuk meg a DTO típust a tényleges entitástípus helyett.

A legenerálódó kontroller már használható is. Állítsuk át a zöld nyíl mellett az indítási konfigurációt a projektnevesre, hogy kestrel induljon és így lássuk a konzolon a naplót. Indítsuk a projektet és próbáljuk például lekérni az összes terméket az `api/efproducts` címről.

Figyeljük meg, hogy a controller a konstruktorban igényli meg a DI-tól az EF kontextet, amit a szokásos módon osztályváltozóban tárol el.

## Köztes réteg alkalmazása

A rétegezett architektúra elveit követve gyakori eljárás, hogy a controller nem éri el közvetlenül az EF kontextet, hanem csak egy extra rétegen keresztül. A controller projekt így függetleníthető az EF-től.

Ehhez a megoldáshoz készítsünk külön kontroller változatot. A *Controllers* mappába hozzunk létre egy kontrollert (Add → Controller... → API Controller with read/write actions) `ProductsController` néven.

A megoldáshoz a Bll projektben már létezik a `ProductService` osztály, aminek szintén függősége az EF kontext és megvalósítja szükséges CRUD műveleteket. Az EF gyakorlaton tanultakra visszautalva mutassuk be a műveletek implementációját. Függőségeknél előnyösebb, ha interfészekre hivatkozunk, mert tesztelésnél az interfész mögötti implementációt általában egyszerűbb cserélni. Szerencsére az `IProductService` interfész is már rendelkezésünkre áll.

Injektáljunk `IProductService`-t az új kontrollerbe.

```csharp
private readonly IProductService _productService;
public ProductsController(IProductService productService)
{
    _productService = productService;
}
```

Adjuk meg a DI konténernek, hogy hogyan kell egy `IProductService` típusú függőséget létrehozni. A `ConfigureServices` függvénybe:

```csharp
services.AddTransient<IProductService, ProductService>();
```

A függőség injektálás úgy működik, hogy kontrollereket is a központi DI komponens példányosítja, és ilyenkor megvizsgálja a konstruktor paramétereket. Ha a konténerben talál alkalmas beregisztrált osztályt, akkor azt létrehozza és átadja a konstruktornak. Ezt hívjuk konstruktor injektálásnak. Ha a létrehozandó függőségnek is vannak konstruktor paraméterei, akkor azokat is megpróbálja feloldani, így rekurzívan a teljes függőségi objektum hierarchiát le tudja kezelni ( ha abban nincs irányított kör).

A regisztráció során több lehetőségünk is van. Egyrészt nem kötelező interfészt megadni egy osztály beregisztrálásához, az osztályt önmagában is be lehet regisztrálni, ilyenkor a konstruktorban is osztályként kell elkérni a függőségeket.

Háromféle példányosítási stratégiával regisztrálhatjuk be az osztályainkat:

- **Transient**: minden egyes injektálás során új példány jön létre
- **Scoped**: HTTP kérésenként egy példány kerül létrehozásra és a kérésen belül mindenkinek ez lesz injektálva
- **Singleton**: mindenkinek ugyanaz a példány kerül átadásra kéréstől függetlenül

Írjunk új `Get()` változatot az eredeti helyett a `ProductsController`-be az `IProductService` függőséget felhasználva:

```csharp
[HttpGet]
public IEnumerable<Product> Get()
{
    return _productService.GetProducts();
}
```

Próbáljuk ki (`api/products`). A konzolon láthatóan hibát kapunk, mert a `ProductService` lekérdező függvénye eager loading-gal (`Include`) navigációs property-ket is kitölt, így könnyen hivatkozási kör jön létre, amit a JSON sorosító alapértelmezésben kivétellel jutalmaz. A sorosítást az MVC middleware végzi, a kontrollerfüggvény visszatérési értékét sorosítja a HTTP tartalomegyeztetési szabályok szerint. Böngésző kliens esetén alapesetben JSON formátum lesz a befutó. Persze a sorosítás ennél közvetlenebbül is [konfigurálható](https://docs.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting), ha szükséges. A sorosítók beállítását tehát az MVC middleware konfigurációja során adhatjuk meg. Állítsuk be, hogy a sorosító oldja fel a kört úgy, hogy az újból sorosítandó elemet ne sorosítsa, azaz ne zárja be a kört.

```csharp
services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
    //leanpub-start-insert
    .AddJsonOptions(
        json => json.SerializerSettings.ReferenceLoopHandling
                = ReferenceLoopHandling.Ignore);
    //leanpub-end-insert
```

T> Nem csak ezzel a stratégiával oldható fel a körkörös hivatkozás, lásd például [itt](https://stackoverflow.com/a/23461179/472575).

Próbáljuk ki így is az alkalmazást: ugyanannyi terméket kapunk vissza, de az egyes termékekről jóval több adatot.

## REST konvenciók alkalmazása

A REST megközelítés nem csak átviteli közegnek tekinti a HTTP-t, hanem a protokoll részeit felhasználja, hogy kiegészítő információkat vigyen át. Emiatt előnyös lenne, ha nagyobb ellenőrzésünk lenne a HTTP válasz felett, szerencsére az ASP.NET Core biztosítja ehhez a megfelelő API-kat.

Egyik legegyszerűbb ilyen irányelv, hogy a lekérdezések eredményeként, ha megtaláltuk és visszaadtuk a kért adatokat, akkor **200 (OK)** HTTP válaszkódot adjunk. 

T> A HTTP kérést érintő irányelvekről egy jó összefoglaló elérhető [itt](https://www.restapitutorial.com/lessons/httpmethods.html).

Az eddig megírt `Get()` függvényünk most is **200 (OK)**-ot ad, ezt le is ellenőrizhetjük a böngészőnk hálózati monitorozó eszközében.

T> A HTTP kommunikáció megfigyelésére használhatjuk a böngészők beépített eszközeit, minta mailyen a [Firefox Developer Tools](https://developer.mozilla.org/en-US/docs/Tools), illetve [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/). Általában az \[F12\] billentyűvel aktiválhatók. Emellett, ha egy teljesértékű HTTP kliensre van szükségünk, amivel például könnyen tudunk nem csak GET kéréseket küldeni, akkor a [Postman](https://www.getpostman.com/) és a [Fiddler](https://www.telerik.com/download/fiddler) külön telepítendő eszközök ajánlhatók. A Fiddler, mint proxy megoldás, egy Windows gépen folyó HTTP kommunikáció megfigyelésére is alkalmas.

Első körben a két lekérdező függvényt írjuk át úgy, hogy a HTTP válaszkódokat explicit megadjuk. A jelenlegi legmodernebb mód ehhez az `AsyncResult<>` használata. Elég `T`-t visszaadnunk a függvényben, automatikusan `AsyncResult<T>` típussá konvertálódik. Tehát elvileg írhatnánk ezt:

```csharp
//NEM FORDUL!
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _productService.GetProducts();
}
```

Azonban ez nem fordul, mert interfész típus esetén nem működik a konverzió. Konkrét típust, pl. egy listát kell megadnunk.

```csharp
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _productService.GetProducts()
    //leanpub-start-insert
        .ToList();
    //leanpub-end-insert
}
```

T> Ez most nem volt nagy érvágás teljesítményügyileg, a BLL-ben már legyártjuk a listát, csak épp `IEnumerable<>`-ként adjuk át. A fenti `ToList` gyakorlatilag nem csinál semmit.

A másik `Get` függvény még egyszerűbb:

```csharp
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    return _productService.GetProduct(id);
}
```

Próbáljuk ki mindkét függvényt, ellenőrizzük a státuszkódokat is.

Ami fura, hogy még mindig nem állítottunk explicit státuszkódokat. A logikánk most még nagyon egyszerű, csak a hibamentes ágat néztük, így eddig az `ActionResult` alapértelmezései megoldották, hogy **200 (OK)**-ot kapjunk.

Most viszont következzen egy létrehozó művelet:

```csharp
[HttpPost]
public ActionResult<Product> Post([FromBody] Product product)
{
    var created = _productService.InsertProduct(product);
    return CreatedAtAction(nameof(Get), new { id = created.Id }, created);
}
```

Itt már látszik az `ActionResult` haszna. A konvenciónak megfelelően 201-es kódot akarunk visszaadni. Ehhez a `ControllerBase` ősosztály biztosít segédfüggvényt. A segédfüggvény olyan `ActionResult` leszármazottat ad vissza, ami 201-es kódot szolgáltat a kliensnek. Másik konvenció, hogy a *Location* HTTP fejlécben legyen egy URL az új termék lekérdező műveletének meghívásához.

Próbáljuk ki a műveletet Fiddlerben vagy Postmanben! Egy `Product`-ot kell felküldenünk. JSON formátumú példát találunk a kóddarabkák között. Ne felejtsük el a *Content-Type* fejlécet  application/json-re állítani! Figyeljük meg a kapott választ. A válaszból másoljuk ki a *Location* fejlécből az URL-t és hívjuk meg böngészőből.

A módosító, törlő műveleteknél a konvenció megengedi, hogy üres törzsű (body) választ adjunk, ilyenkor a válaszkód **204 (No Content)**. Ilyesfajta válasz előállításához is van segédfüggvény, illetve elég csak az `IActionResult` interfészt megadni visszatérési típusnak:

```csharp
[HttpPut("{id}")]
public IActionResult Put(int id, [FromBody] Product product)
{
    _productService.UpdateProduct(id, product);
    return NoContent();
}

[HttpDelete("{id}")]
public IActionResult Delete(int id)
{
    _productService.DeleteProduct(id);
    return NoContent();
}
```

Próbáljuk kitörölni az újonnan felvett terméket Fiddler/Postman-ből (*DELETE* igés kérés az `api/products/<új id>` címre). Sikerülnie kell, mert még nincs rá idegen kulcs hivatkozás.

A fenti műveletek során csak a hibamentes ágat valósítottuk meg. A többi ágat (hibás kérés, erőforrás nem található stb.) a felesleges boilerplate kódok elkerülése végett majd külön middleware-ekben illetve MVC filterekben valósítjuk meg a későbbiekben.

## DTO osztályok

Közvetlenül az entitástípusok sorosítása láthatóan működik, de nem szerencsés. A modell kifejezetten az EF számára lett megalkotva, illetve hogy a lekérdező műveleteket minél kényelmesebben végezhessük. A kliensoldal számára érdemes külön modellt megalkotni, a DTO (*Data Transfer Object*) modellt, ami a kliensoldal igényeit veszi figyelembe: **pontosan** annyi adatot tartalmaz, amire a kliensnek szüksége van.

A *Bll* projektben jelenleg egy nagyon egyszerű DTO modell található a *Dtos* mappában:

- nincs benne minden navigációs property, pl. `Category.Products`
- nincs benne a kapcsolótáblát reprezentáló entitás
- a termékből közvetlenül elérhetők a megrendelések

A különféle modellek közötti leképezésnél jól jönnek az ún. object mapper-ek, melyek segítenek elkerülni a leképezésnél nagyon gyakori repetitív kódokat, mint amilyen az `x.Prop=y.Prop` jellegű property érték másolgatás.

Adjuk hozzá a projekthez az *AutoMapper.Extensions.Microsoft.DependencyInjection* csomagot. A `ConfigureServices`-ben adjuk hozzá és konfiguráljuk a leképezési szolgáltatást.

```csharp
/*kóddarabka*/
services.AddAutoMapper(cfg =>
{
    cfg.CreateMap<Entities.Product, Dtos.Product>()
        .ForMember(dto => dto.Orders, opt => opt.Ignore())
        .AfterMap((p, dto, ctx) =>
            dto.Orders = p.ProductOrders.Select(po =>
            ctx.Mapper.Map<Dtos.Order>(po.Order)).ToList()).ReverseMap();
    cfg.CreateMap<Entities.Order, Dtos.Order>().ReverseMap();
    cfg.CreateMap<Entities.Category, Dtos.Category>().ReverseMap();
});
```

T> Ez a konfiguráció igen nagyra nőhet, ez esetben érdemes lehet kiszervezni vagy [profilokat](http://docs.automapper.org/en/stable/Configuration.html#profile-instances) alkalmazni.

Injektáltassunk be a leképzőt reprezentáló `IMapper` típusú objektumot a kontrollerbe.

```csharp
//leanpub-start-insert
private readonly IMapper _mapper;
//leanpub-end-insert
public ProductsController(IProductService productService
                        //leanpub-start-insert
                         ,IMapper mapper)
                        //leanpub-end-insert
{
    _productService = productService;
    //leanpub-start-insert
    _mapper = mapper;
    //leanpub-end-insert
}
```

Az entitásokra mutató névteret cseréljük ki a DTO-kra mutató névtérre:

```csharp
//leanpub-start-delete
using WebApiLabor.Entities;
//leanpub-end-delete
using WebApiLabor.Api.Dtos;
```

Írjuk át a REST műveleteket a leképzőt alkalmazva (a Delete-en nem kell változtatni):

```csharp
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _mapper.Map<List<Product>>(_productService.GetProducts())
        .ToList();
}

[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    return _mapper.Map<Product>(_productService.GetProduct(id));
}

[HttpPost]
public ActionResult<Product> Post([FromBody] Product product)
{
    var created = _productService
        .InsertProduct(_mapper.Map<Entities.Product>(product));
    return CreatedAtAction(
                nameof(Get),
                new { id = created.Id },
                _mapper.Map<Product>(created)
    );
}

[HttpPut("{id}")]
public IActionResult Put(int id, [FromBody] Product product)
{
    _productService.
        UpdateProduct(id, _mapper.Map<Entities.Product>(product));
    return NoContent();
}
```

Próbáljuk ki valamelyik műveletet.

T> A többrétegű architektúránál elméletben minden rétegnek külön objektummodellje kellene, hogy legyen DAL: EF entitások, BLL: domain objektumok, Kontroller: DTO-k, viszont ha a domain objektumok nem visznek plusz funkciót a rendszerbe, el szoktuk hagyni.

T> A DTO leképezést sok helyen végezhetnénk. Más megközelítések szerint az adatátviteli réteg feladata lenne, esetünkben a kontrolleré.

T> Ha a DTO mappelést az üzleti szolgáltatás rétegben szeretnénk végezni, akkor akár az SQL szintjén is konvertálhatjuk az [AutoMapper](http://docs.automapper.org/en/stable/Queryable-Extensions.html) vagy a [QueryMutator](https://github.com/yugabe/QueryMutator) NuGet csomag segítségével. Ilyenkor csak a DTO képzéshez szükséges adatokat kérdezzük le az adatbázisból.

## Async

Async műveletek alkalmazásával hatékonyságjavulást érhetünk el: nem feltétlenül az egyes műveletink lesznek gyorsabbak, hanem időegység alatt több műveletet tudunk kiszolgálni. Ennek oka, hogy az `await`-nél (például egy adatbázis művelet elküldésekor) a várakozási idejére történő kiugrásnál, ha vissza tudunk ugrálni az ASP.NET engine szintjéig, akkor a végrehajtó környezet a kiszolgáló szálat a várakozás idejére más kérés kiszolgálására felhasználhatja.

T> Ökölszabály, hogy ha elköteleztük magunkat az aszinkronitás mellett, akkor ha megoldható, az aszinkronitást vezessük végig a kontrollertől az adatbázis művelet végrehajtásáig minden rétegben. Ha egy API-nak van *TAP* jellegű változata, akkor azt részesítsük előnyben (pl. `SaveChanges` helyett `SaveChangesAsync`). Ha aszinkronból szinkronba váltunk, csökkentjük a hatékonyságot, rosszabb esetben deadlock-ot is [előidézhetünk](https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html).

Vezessük végig az aszinkronitást egy művelet teljes végrehajtásán:

```csharp
public interface IProductService
{
    //...
    void UpdateProduct(int productId, Product updatedProduct);
    //leanpub-start-insert
    Task UpdateProductAsync(int productId, Product updatedProduct);
    //leanpub-end-insert
    //..
}

//TIPP: másoljuk le a szinron változatot, azt módosítsuk
//leanpub-start-insert
public async Task UpdateProductAsync(int productId, Product updatedProduct)
//leanpub-end-insert
{
    updatedProduct.Id = productId;
    var entry = _context.Attach(updatedProduct);
    entry.State = EntityState.Modified;

    try
    {
        //leanpub-start-insert
        await _context.SaveChangesAsync();
        //leanpub-end-insert
    }
    catch (DbUpdateConcurrencyException)
    {
        throw new EntityNotFoundException("Nem található a termék");
    }
}

//leanpub-start-insert
public async Task<IActionResult> Put(int id, [FromBody] Product product)
//leanpub-end-insert
{
    await _productService.
    //leanpub-start-insert
        UpdateProductAsync(id, _mapper.Map<Entities.Product>(product));
    //leanpub-end-insert
    return NoContent();
}
```

Próbáljuk ki, például küldjünk PUT-ot az `api/products/1` címre, állítsuk be a *Content-Type: application/json* fejlécet és a POST-nál használt JSON-t küldjük a törzsben. Ezzel az 1-es `id`-jű termék adatait fogjuk felülírni.