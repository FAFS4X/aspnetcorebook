# ASP.NET Core webszolgáltatások I.

## Kiegészítő anyagok, segédeszközök

- kóddarabka fájl: aspnetcorerest.md
- kiinduló solution: https://github.com/bmeaut/WebApiLab2019/tree/init
  - elég csak zip-ként letölteni, nem kell klónozni
  - figyeljünk rá, hogy az *init* ágat töltsük le
- Fiddler vagy Postman HTTP kérések küldéséhez
- [NSwag Studio](https://github.com/RicoSuter/NSwag/releases) a klienskód generáláshoz

## Kiinduló projektek beüzemelése

A kiinduló solution két .NET Standard 2.0 osztálykönyvtárat foglal magába, melyek egy N-rétegű architektúra egy-egy rétegét valósítják meg

- **WebApiLabor.DAL**: lényegében az Entity Framework gyakorlatok anyagát tartalmazza, ez az adatelérési rétegünk.
- **WebApiLabor.Bll**: a DAL rétegre épülő, az üzleti logikát megvalósító szolgáltatásokat tartalmazza. A *Dtos*, *Exceptions* mappák egyelőre nem érdekesek, első körben nem fogjuk még a bennük lévő típusokat használni.

Adjunk hozzá a solution-höz egy új Web projektet (C# → Web → ASP.NET Core Web Application (.NET Core)), a neve legyen *WebApiLabor.API*.

A következő dialógusablakban válasszuk ki az *ASP.NET Core 2.2* opciót és azon belül a API sablont. Más egyéb extrát (HTTPS, Docker, stb.) ne kérjünk. Adjuk hozzá projekt függőségként a *Bll* projektet.

### Adatbázis inicializálása Code-First migrációval

Az EF gyakorlatok alapján megoldható, így itt csak rövidítve ismertetjük.

Hozzunk létre egy új LocalDB adatbázist egy választott névvel, pl. neptun kód, northwind, stb. A `NorthwindContext.OnConfiguring`-ban lévő connection string-ben ennek megfelelően írjuk át az adatbázis nevét.

Fordítsuk a teljes solution-t, állítsuk be indítandó (startup) projektnek az új Web API projektet. A *Package Manager Console*-t nyissuk meg és ellenőrizzük, állítsuk be Default Project-ként a DAL projektet.

```powershell
Update-Database
```

W> Fontos, hogy a fenti parancs két projektet ismerjen: azt, amelyikben a kontext van, ill. a kontextet használó futtatható projektet. A VS Package Manager Console-jában futtatva alapértelmezésben az előbbit a Default Project értéke adja meg, utóbbit az indítandó projekt. Továbbá ezeket a projekteket meg lehet adni [paraméterként](https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/powershell#common-parameters) is.

Ellenőrizzük, hogy rendben lefutott-e a migráció, létrejöttek-e az adatbázis objektumok, feltöltődtek-e a táblák.

## Az EF kontext és naplózás bekötése az ASP.NET Core DI rendszerébe

Most már van `ConfigureServices` függvényünk (lásd ASP.NET Core bevezető gyakorlatot), regisztráljuk az EF kontextet és az EF naplózó szolgáltatást a DI rendszerbe.

A kontext regisztrálása a `Startup.ConfigureServices` függvénybe:

```csharp
services.AddDbContext<NorthwindContext>(o =>
    o.UseSqlServer(Configuration["ConnectionStrings:DefaultConnection"])
    .ConfigureWarnings(
        c => c.Throw(RelationalEventId.QueryClientEvaluationWarning)));
```

Az EF naplózást az ASP.NET Core naplózó rendszere végzi, amit az alapértelmezett `WebHost` már inicializál, így ezzel kapcsolatban nincs teendőnk. Kommentezzük ki a szükségtelenné vált `GetLoggerFactory`, `OnConfiguring` függvényeket a `NorthwindContext` osztályban. Cserébe egy új konstruktorra lesz szükségünk, ami `DbContextOptions<NorthwindContext>`-et vár.

```csharp
public NorthwindContext(DbContextOptions<NorthwindContext> options)
    : base(options){}
```

Az *appsettings.Development.json*-ba vegyük fel a connection string-et. Átmásolhatjuk a kikommentezett részből vagy az SQL Server Object Explorer-ből.

```javascript
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "System": "Information",
      "Microsoft": "Information"
    }
  },
  //leanpub-start-insert
  "ConnectionStrings": {
    "DefaultConnection": "<connection string>"
  }
  //leanpub-end-insert
}
```

Fordítást követően kipróbálhatjuk az EF működését egy adatbázis újrainicializációval.

```powershell
Update-Database 0
Update-Database
```

T> Itt mutatkozik meg, hogy a migráció lényegében egy teljes alkalmazásindítást jelent a `Startup` osztályon keresztül, inicializálódik a DI konténer, a konfigurációs objektum, stb.

## EF kontext használata a kontroller rétegben

Bár architektúra szempontból nem a legszebb, a BLL réteget gyakorlatilag mellőzve közvetlenül is használhatjuk az EF entitásokat a kontrollerek megvalósításánál.  A *Controllers* mappában hozzunk létre egy kontrollert (Add → Controller... → API Controller with actions using Entity Framework). A felbukkanó ablakban válasszuk ki a `Product` entitás osztályt, a kontextet és adjunk meg nevet ( `EFProductsController`).

W> Figyeljünk rá, hogy ne a `Dto` névtérből adjuk meg a DTO típust a tényleges entitástípus helyett.

A legenerálódó kontroller már használható is. Állítsuk át a zöld nyíl mellett az indítási konfigurációt a projektnevesre, hogy kestrel induljon és így lássuk a konzolon a naplót. Indítsuk a projektet és próbáljuk például lekérni az összes terméket az `api/efproducts` címről.

Figyeljük meg, hogy a controller a konstruktorban igényli meg a DI-tól az EF kontextet, amit a szokásos módon osztályváltozóban tárol el.

## Köztes réteg alkalmazása

A rétegezett architektúra elveit követve gyakori eljárás, hogy a controller nem éri el közvetlenül az EF kontextet, hanem csak egy extra rétegen keresztül. A controller projekt így függetleníthető az EF-től.

Ehhez a megoldáshoz készítsünk külön kontroller változatot. A *Controllers* mappába hozzunk létre egy kontrollert (Add → Controller... → API Controller with read/write actions) `ProductsController` néven.

A megoldáshoz a Bll projektben már létezik a `ProductService` osztály, aminek szintén függősége az EF kontext és megvalósítja szükséges CRUD műveleteket. Az EF gyakorlaton tanultakra visszautalva mutassuk be a műveletek implementációját. Függőségeknél előnyösebb, ha interfészekre hivatkozunk, mert tesztelésnél az interfész mögötti implementációt általában egyszerűbb cserélni. Szerencsére az `IProductService` interfész is már rendelkezésünkre áll.

Injektáljunk `IProductService`-t az új kontrollerbe.

```csharp
private readonly IProductService _productService;
public ProductsController(IProductService productService)
{
    _productService = productService;
}
```

Adjuk meg a DI konténernek, hogy hogyan kell egy `IProductService` típusú függőséget létrehozni. A `ConfigureServices` függvénybe:

```csharp
services.AddTransient<IProductService, ProductService>();
```

A függőség injektálás úgy működik, hogy kontrollereket is a központi DI komponens példányosítja, és ilyenkor megvizsgálja a konstruktor paramétereket. Ha a konténerben talál alkalmas beregisztrált osztályt, akkor azt létrehozza és átadja a konstruktornak. Ezt hívjuk konstruktor injektálásnak. Ha a létrehozandó függőségnek is vannak konstruktor paraméterei, akkor azokat is megpróbálja feloldani, így rekurzívan a teljes függőségi objektum hierarchiát le tudja kezelni ( ha abban nincs irányított kör).

A regisztráció során több lehetőségünk is van. Egyrészt nem kötelező interfészt megadni egy osztály beregisztrálásához, az osztályt önmagában is be lehet regisztrálni, ilyenkor a konstruktorban is osztályként kell elkérni a függőségeket.

Háromféle példányosítási stratégiával regisztrálhatjuk be az osztályainkat:

- **Transient**: minden egyes injektálás során új példány jön létre
- **Scoped**: HTTP kérésenként egy példány kerül létrehozásra és a kérésen belül mindenkinek ez lesz injektálva
- **Singleton**: mindenkinek ugyanaz a példány kerül átadásra kéréstől függetlenül

Írjunk új `Get()` változatot az eredeti helyett a `ProductsController`-be az `IProductService` függőséget felhasználva:

```csharp
[HttpGet]
public IEnumerable<Product> Get()
{
    return _productService.GetProducts();
}
```

Próbáljuk ki (`api/products`). A konzolon láthatóan hibát kapunk, mert a `ProductService` lekérdező függvénye eager loading-gal (`Include`) navigációs property-ket is kitölt, így könnyen hivatkozási kör jön létre, amit a JSON sorosító alapértelmezésben kivétellel jutalmaz. A sorosítást az MVC middleware végzi, a kontrollerfüggvény visszatérési értékét sorosítja a HTTP tartalomegyeztetési szabályok szerint. Böngésző kliens esetén alapesetben JSON formátum lesz a befutó. Persze a sorosítás ennél közvetlenebbül is [konfigurálható](https://docs.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting), ha szükséges. A sorosítók beállítását tehát az MVC middleware konfigurációja során adhatjuk meg. Állítsuk be, hogy a sorosító oldja fel a kört úgy, hogy az újból sorosítandó elemet ne sorosítsa, azaz ne zárja be a kört.

```csharp
services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
    //leanpub-start-insert
    .AddJsonOptions(
        json => json.SerializerSettings.ReferenceLoopHandling
                = ReferenceLoopHandling.Ignore);
    //leanpub-end-insert
```

T> Nem csak ezzel a stratégiával oldható fel a körkörös hivatkozás, lásd például [itt](https://stackoverflow.com/a/23461179/472575).

Próbáljuk ki így is az alkalmazást: ugyanannyi terméket kapunk vissza, de az egyes termékekről jóval több adatot.

## REST konvenciók alkalmazása

A REST megközelítés nem csak átviteli közegnek tekinti a HTTP-t, hanem a protokoll részeit felhasználja, hogy kiegészítő információkat vigyen át. Emiatt előnyös lenne, ha nagyobb ellenőrzésünk lenne a HTTP válasz felett, szerencsére az ASP.NET Core biztosítja ehhez a megfelelő API-kat.

Egyik legegyszerűbb ilyen irányelv, hogy a lekérdezések eredményeként, ha megtaláltuk és visszaadtuk a kért adatokat, akkor **200 (OK)** HTTP válaszkódot adjunk. 

T> A HTTP kérést érintő irányelvekről egy jó összefoglaló elérhető [itt](https://www.restapitutorial.com/lessons/httpmethods.html).

Az eddig megírt `Get()` függvényünk most is **200 (OK)**-ot ad, ezt le is ellenőrizhetjük a böngészőnk hálózati monitorozó eszközében.

T> A HTTP kommunikáció megfigyelésére használhatjuk a böngészők beépített eszközeit, minta mailyen a [Firefox Developer Tools](https://developer.mozilla.org/en-US/docs/Tools), illetve [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/). Általában az \[F12\] billentyűvel aktiválhatók. Emellett, ha egy teljesértékű HTTP kliensre van szükségünk, amivel például könnyen tudunk nem csak GET kéréseket küldeni, akkor a [Postman](https://www.getpostman.com/) és a [Fiddler](https://www.telerik.com/download/fiddler) külön telepítendő eszközök ajánlhatók. A Fiddler, mint proxy megoldás, egy Windows gépen folyó HTTP kommunikáció megfigyelésére is alkalmas.

Első körben a két lekérdező függvényt írjuk át úgy, hogy a HTTP válaszkódokat explicit megadjuk. A jelenlegi legmodernebb mód ehhez az `AsyncResult<>` használata. Elég `T`-t visszaadnunk a függvényben, automatikusan `AsyncResult<T>` típussá konvertálódik. Tehát elvileg írhatnánk ezt:

```csharp
//NEM FORDUL!
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _productService.GetProducts();
}
```

Azonban ez nem fordul, mert interfész típus esetén nem működik a konverzió. Konkrét típust, pl. egy listát kell megadnunk.

```csharp
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _productService.GetProducts()
    //leanpub-start-insert
        .ToList();
    //leanpub-end-insert
}
```

T> Ez most nem volt nagy érvágás teljesítményügyileg, a BLL-ben már legyártjuk a listát, csak épp `IEnumerable<>`-ként adjuk át. A fenti `ToList` gyakorlatilag nem csinál semmit.

A másik `Get` függvény még egyszerűbb:

```csharp
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    return _productService.GetProduct(id);
}
```

Próbáljuk ki mindkét függvényt, ellenőrizzük a státuszkódokat is.

Ami fura, hogy még mindig nem állítottunk explicit státuszkódokat. A logikánk most még nagyon egyszerű, csak a hibamentes ágat néztük, így eddig az `ActionResult` alapértelmezései megoldották, hogy **200 (OK)**-ot kapjunk.

Most viszont következzen egy létrehozó művelet:

```csharp
[HttpPost]
public ActionResult<Product> Post([FromBody] Product product)
{
    var created = _productService.InsertProduct(product);
    return CreatedAtAction(nameof(Get), new { id = created.Id }, created);
}
```

Itt már látszik az `ActionResult` haszna. A konvenciónak megfelelően 201-es kódot akarunk visszaadni. Ehhez a `ControllerBase` ősosztály biztosít segédfüggvényt. A segédfüggvény olyan `ActionResult` leszármazottat ad vissza, ami 201-es kódot szolgáltat a kliensnek. Másik konvenció, hogy a *Location* HTTP fejlécben legyen egy URL az új termék lekérdező műveletének meghívásához.

Próbáljuk ki a műveletet Fiddlerben vagy Postmanben! Egy `Product`-ot kell felküldenünk. JSON formátumú példát találunk a kóddarabkák között. Ne felejtsük el a *Content-Type* fejlécet  application/json-re állítani! Figyeljük meg a kapott választ. A válaszból másoljuk ki a *Location* fejlécből az URL-t és hívjuk meg böngészőből.

A módosító, törlő műveleteknél a konvenció megengedi, hogy üres törzsű (body) választ adjunk, ilyenkor a válaszkód **204 (No Content)**. Ilyesfajta válasz előállításához is van segédfüggvény, illetve elég csak az `IActionResult` interfészt megadni visszatérési típusnak:

```csharp
[HttpPut("{id}")]
public IActionResult Put(int id, [FromBody] Product product)
{
    _productService.UpdateProduct(id, product);
    return NoContent();
}

[HttpDelete("{id}")]
public IActionResult Delete(int id)
{
    _productService.DeleteProduct(id);
    return NoContent();
}
```

Próbáljuk kitörölni az újonnan felvett terméket Fiddler/Postman-ből (*DELETE* igés kérés az `api/products/<új id>` címre). Sikerülnie kell, mert még nincs rá idegen kulcs hivatkozás.

A fenti műveletek során csak a hibamentes ágat valósítottuk meg. A többi ágat (hibás kérés, erőforrás nem található stb.) a felesleges boilerplate kódok elkerülése végett majd külön middleware-ekben illetve MVC filterekben valósítjuk meg a későbbiekben.

## DTO osztályok

Közvetlenül az entitástípusok sorosítása láthatóan működik, de nem szerencsés. A modell kifejezetten az EF számára lett megalkotva, illetve hogy a lekérdező műveleteket minél kényelmesebben végezhessük. A kliensoldal számára érdemes külön modellt megalkotni, a DTO (*Data Transfer Object*) modellt, ami a kliensoldal igényeit veszi figyelembe: **pontosan** annyi adatot tartalmaz, amire a kliensnek szüksége van.

A *Bll* projektben jelenleg egy nagyon egyszerű DTO modell található a *Dtos* mappában:

- nincs benne minden navigációs property, pl. `Category.Products`
- nincs benne a kapcsolótáblát reprezentáló entitás
- a termékből közvetlenül elérhetők a megrendelések

A különféle modellek közötti leképezésnél jól jönnek az ún. object mapper-ek, melyek segítenek elkerülni a leképezésnél nagyon gyakori repetitív kódokat, mint amilyen az `x.Prop=y.Prop` jellegű property érték másolgatás.

Adjuk hozzá a projekthez az *AutoMapper.Extensions.Microsoft.DependencyInjection* csomagot. A `ConfigureServices`-ben adjuk hozzá és konfiguráljuk a leképezési szolgáltatást.

```csharp
/*kóddarabka*/
services.AddAutoMapper(cfg =>
{
    cfg.CreateMap<Entities.Product, Dtos.Product>()
        .ForMember(dto => dto.Orders, opt => opt.Ignore())
        .AfterMap((p, dto, ctx) =>
            dto.Orders = p.ProductOrders.Select(po =>
            ctx.Mapper.Map<Dtos.Order>(po.Order)).ToList()).ReverseMap();
    cfg.CreateMap<Entities.Order, Dtos.Order>().ReverseMap();
    cfg.CreateMap<Entities.Category, Dtos.Category>().ReverseMap();
});
```

T> Ez a konfiguráció igen nagyra nőhet, ez esetben érdemes lehet kiszervezni vagy [profilokat](http://docs.automapper.org/en/stable/Configuration.html#profile-instances) alkalmazni.

Injektáltassunk be a leképzőt reprezentáló `IMapper` típusú objektumot a kontrollerbe.

```csharp
//leanpub-start-insert
private readonly IMapper _mapper;
//leanpub-end-insert
public ProductsController(IProductService productService
                        //leanpub-start-insert
                         ,IMapper mapper)
                        //leanpub-end-insert
{
    _productService = productService;
    //leanpub-start-insert
    _mapper = mapper;
    //leanpub-end-insert
}
```

Az entitásokra mutató névteret cseréljük ki a DTO-kra mutató névtérre:

```csharp
//leanpub-start-delete
using WebApiLabor.Entities;
//leanpub-end-delete
using WebApiLabor.Api.Dtos;
```

Írjuk át a REST műveleteket a leképzőt alkalmazva (a Delete-en nem kell változtatni):

```csharp
[HttpGet]
public ActionResult<IEnumerable<Product>> Get()
{
    return _mapper.Map<List<Product>>(_productService.GetProducts())
        .ToList();
}

[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    return _mapper.Map<Product>(_productService.GetProduct(id));
}

[HttpPost]
public ActionResult<Product> Post([FromBody] Product product)
{
    var created = _productService
        .InsertProduct(_mapper.Map<Entities.Product>(product));
    return CreatedAtAction(
                nameof(Get),
                new { id = created.Id },
                _mapper.Map<Product>(created)
    );
}

[HttpPut("{id}")]
public IActionResult Put(int id, [FromBody] Product product)
{
    _productService.
        UpdateProduct(id, _mapper.Map<Entities.Product>(product));
    return NoContent();
}
```

Próbáljuk ki valamelyik műveletet.

T> A többrétegű architektúránál elméletben minden rétegnek külön objektummodellje kellene, hogy legyen DAL: EF entitások, BLL: domain objektumok, Kontroller: DTO-k, viszont ha a domain objektumok nem visznek plusz funkciót a rendszerbe, el szoktuk hagyni.

T> A DTO leképezést sok helyen végezhetnénk. Más megközelítések szerint az adatátviteli réteg feladata lenne, esetünkben a kontrolleré.

T> Ha a DTO mappelést az üzleti szolgáltatás rétegben szeretnénk végezni, akkor akár az SQL szintjén is konvertálhatjuk az [AutoMapper](http://docs.automapper.org/en/stable/Queryable-Extensions.html) vagy a [QueryMutator](https://github.com/yugabe/QueryMutator) NuGet csomag segítségével. Ilyenkor csak a DTO képzéshez szükséges adatokat kérdezzük le az adatbázisból.

## Async

Async műveletek alkalmazásával hatékonyságjavulást érhetünk el: nem feltétlenül az egyes műveletink lesznek gyorsabbak, hanem időegység alatt több műveletet tudunk kiszolgálni. Ennek oka, hogy az `await`-nél (például egy adatbázis művelet elküldésekor) a várakozási idejére történő kiugrásnál, ha vissza tudunk ugrálni az ASP.NET engine szintjéig, akkor a végrehajtó környezet a kiszolgáló szálat a várakozás idejére más kérés kiszolgálására felhasználhatja.

T> Ökölszabály, hogy ha elköteleztük magunkat az aszinkronitás mellett, akkor ha megoldható, az aszinkronitást vezessük végig a kontrollertől az adatbázis művelet végrehajtásáig minden rétegben. Ha egy API-nak van *TAP* jellegű változata, akkor azt részesítsük előnyben (pl. `SaveChanges` helyett `SaveChangesAsync`). Ha aszinkronból szinkronba váltunk, csökkentjük a hatékonyságot, rosszabb esetben deadlock-ot is [előidézhetünk](https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html).

Vezessük végig az aszinkronitást egy művelet teljes végrehajtásán:

```csharp
public interface IProductService
{
    //...
    void UpdateProduct(int productId, Product updatedProduct);
    //leanpub-start-insert
    Task UpdateProductAsync(int productId, Product updatedProduct);
    //leanpub-end-insert
    //..
}

//TIPP: másoljuk le a szinron változatot, azt módosítsuk
//leanpub-start-insert
public async Task UpdateProductAsync(int productId, Product updatedProduct)
//leanpub-end-insert
{
    updatedProduct.Id = productId;
    var entry = _context.Attach(updatedProduct);
    entry.State = EntityState.Modified;

    try
    {
        //leanpub-start-insert
        await _context.SaveChangesAsync();
        //leanpub-end-insert
    }
    catch (DbUpdateConcurrencyException)
    {
        throw new EntityNotFoundException("Nem található a termék");
    }
}

//leanpub-start-insert
public async Task<IActionResult> Put(int id, [FromBody] Product product)
//leanpub-end-insert
{
    await _productService.
    //leanpub-start-insert
        UpdateProductAsync(id, _mapper.Map<Entities.Product>(product));
    //leanpub-end-insert
    return NoContent();
}
```

Próbáljuk ki, például küldjünk PUT-ot az `api/products/1` címre, állítsuk be a *Content-Type: application/json* fejlécet és a POST-nál használt JSON-t küldjük a törzsben. Ezzel az 1-es `id`-jű termék adatait fogjuk felülírni.

## Egyszerű kliens

A tárgy tematikájának ugyan nem része a kliensoldal, de demonstrációs céllal egy egyszerű kliensoldalról indított hívást implementálunk. A webes API-khoz nagyon sokféle technikával írhatunk klienst, mivel gyakorlatilag csak két képességgel kell rendelkezni:

1. HTTP alapú kommunikáció, HTTP kérések küldése, a válasz feldolgozása
2. JSON sorosítás

A fentiekhez szinte minden manapság használt kliensoldali technológia ad támogatást. Mi most egy sima, klasszikus .NET Framework alapú konzol alkalmazást írunk kliens gyanánt.

Adjunk a solution-höz egy konzolos projektet (.NET Framework, legalább v4.6.1) *WebApiLabor.Client* néven. A C# verziót emeljük föl a korábbi C# gyakorlathoz hasonlóan legalább 7.1-re a projekttulajdonságok *Build* fülén, az *Advanced* gombbal. A *Program.cs*-ben írjuk meg az egy terméket lekérdező függvényt (`GetProductAsync`) és hívjuk meg a `Main` függvényből.

```csharp
static async Task Main(string[] args)
{
    Console.Write("ProductId: ");
    var id = Console.ReadLine();
    await GetProductAsync(Int32.Parse(id));

    Console.ReadKey();
}

public static async Task GetProductAsync(int id)
{
    using (var client = new HttpClient())
    {
        /*Port-ot írjuk át a szervernek megfelelően*/
        var response = await client.
            GetAsync(new Uri($"http://localhost:5000/api/Products/{id}"));
        if (response.IsSuccessStatusCode)
        {
            var json = await response.Content.ReadAsStringAsync();
            Console.WriteLine(json);
        }
    }
}
```

T> Ha .NET-ben írjuk a klienst, akkor szinte biztosan a klasszikus .NET Framework-öt kell használnunk, hiszen az elterjedtebb .NET alapú kliens technológiák (WinForms, WPF) .NET Framework alapúak ... legalábbis a .NET Core v3 megjelenéséig.

Állítsuk be, hogy a szerver és a kliensoldal is elinduljon (solution jobb gomb → Set startup projects...)

Próbáljuk ki - a termék nyers JSON formában jelenik meg a konzolon. Ehhez még JSON sorosítót sem kellett használnunk. A következő lépés az lenne, hogy a JSON alapján visszasorosítanánk egy objektumba. Ehhez kliensoldalon is kellene lennie egy Product DTO-nak megfelelő osztálynak. Hogyan jöhetnek létre a kliensoldali modellosztályok?

- kézzel létrehozzuk őket a JSON alapján - macerás
- a DTO-kat osztálykönyvtárba szervezzük, mindkét oldal hivatkozza - csak akkor működik, ha mindkét oldal .NET-es, ráadásul könnyen kaphat az osztálykönyvtár olyan függőséget, ami igazából csak az egyik oldalnak kell csak, így meg mindkét oldal meg fogja kapni.
- generáltatjuk valamilyen eszközzel a szerveroldal alapján - ezt próbáljuk most ki

## OpenAPI/Swagger szerveroldal

Az *OpenAPI* (eredeti nevén: *swagger*) eszközkészlet segítségével egy JSON alapú leírását tudjuk előállítani a szerveroldali API-nknak. A leírás alapján generálhatunk dokumentációt, sőt kliensoldali kódot is a kliensoldali fejlesztők számára. Jelenleg a legfrissebb specifikáció az OpenAPI v3-as (OAS v3). Az egyes verziók dokumentációja elérhető [itt](https://github.com/OAI/OpenAPI-Specification/tree/master/versions).

Az OpenAPI nem .NET specifikus, különféle nyelven írt szervert és a klienst is támogat. Ugyanakkor készültek kifejezetten a .NET-hez is swagger eszközök, ezek közül használunk párat most. .NET környezetben legelterjedtebb eszközkészletek:

- [NSwag](https://github.com/RicoSuter/NSwag) - szerver- és kliensoldali generálás is. Részleges OAS v3 támogatás.
- [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle.AspNetCore) - csak szerveroldali generálás. OAS v3 támogatás betában.
- [AutoRest](https://github.com/Azure/autorest) - *npm* csomag .NET Core függőséggel, csak kliensoldali kódgeneráláshoz
- [Swagger codegen](https://github.com/swagger-api/swagger-codegen) - java alapú kliensoldali generátor

Első lépésként a szerveroldali kódunk alapján swagger leírást generálunk *NSwag* segítségével. Kommentezzük ki a `ProductsController`-en kívül a többi kontroller teljes kódját. A *launchsettings.json*-ben a *launchUrl* értékeket.

```javascript
"profiles": {
  "IIS Express": {
      //..
     //leanpub-start-insert
    "launchUrl": "swagger",
     //leanpub-end-insert
     //..
  },
  "WebApiLabor.Api": {
    //..
    //leanpub-start-insert
    "launchUrl": "swagger",
    //leanpub-end-insert
    //..
    }
  }
}
```

Adjuk hozzá a projekthez az `NSwag.AspNetCore` csomagot, most a `Package Manager Console`-ból. Figyeljünk rá, hogy a *Default project* az Api projektünk legyen - ebbe fog bekerülni az új függőség.

```powershell
Install-Package NSwag.AspNetCore
```

Konfiguráljuk a szükséges szolgáltatásokat a DI rendszerbe.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    //...
    //leanpub-start-insert
    services.AddSwaggerDocument();
    //leanpub-end-insert
}
```

A swagger leíró, ill. a swagger dokumentációs felület kiszolgálására regisztráljunk egy-egy middleware-t.

```csharp
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    //leanpub-start-insert
    app.UseSwagger();
    app.UseSwaggerUi3();
    //leanpub-end-insert
    app.UseMvc();
}
```

Próbáljuk ki, hogy működik-e a dokumentációs felület a **/swagger** útvonalon, illetve a leíró elérhető-e a **/swagger/v1/swagger.json** útvonalon.

T> A swagger leíró linkje megtalálható a dokumentációs felület címsora alatt.

A dokumentációs felületen fedezzük fel a `ProductsController` műveleteit, a visszatérési értékek leírását (példa, illetve modell-leíró), ill. a modell-leírókat a műveletlista alatt. Hívjuk is meg a **/api/Products/{id}** változatot, kitöltve a szükséges paramétert.

Az NSwag képes a kódunk XML kommentjeit hasznosítani a dokumentációs felületen. Írjuk meg egy művelet XML kommentjét.

```csharp
/*kóddarabka*/
/// <summary>
/// Get a specific product with the given identifier
/// </summary>
/// <param name="id">Product's identifier</param>
/// <returns>Returns a specific product with the given identifier</returns>
/// <response code="200">Returns a specific product with the given identifier</response>
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
```

A swagger komponensünk az XML kommenteket nem a forráskódból, hanem egy generált állományból képes kiolvasni. Állítsuk be ennek a generálását a projekt build beállításai között ( Build → XML documentation file). A checkbox bekattintásakor felajánlott értéket el is fogadhatjuk.

![.NET projektbeállítások - XML dokumentációs fájl generálása](images/aspnetcorerest-xmlcomments.png)

Másik kis testreszabási lehetőség, amit kipróbálunk, a felsorolt típusok szövegként való generálása (az egész számos kódolás helyett). A `ConfigureServices`-ben a JSON sorosítást konfiguráljuk:

```csharp
services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2)
    .AddJsonOptions(
        json => json.SerializerSettings.ReferenceLoopHandling
                = ReferenceLoopHandling.Ignore)
     //leanpub-start-insert
    .AddJsonOptions(options =>
        options.SerializerSettings.Converters.
            Add(new StringEnumConverter()));
     //leanpub-end-insert
```

W> Figyeljünk rá, hogy a `StringEnumConverter` a Json.NET-es legyen, ne az EF-es.

Próbáljuk ki, hogy az XML kommentünk megjelenik-e a megfelelő műveletnél, illetve a modell-leírókban a `Product.ShipmentRegion` szöveges értékeket vesz-e fel.

## OpenAPI/Swagger kliensoldal

A kliensoldalt az *NSwag Studio* eszközzel generáltatjuk. Előkészítésként adjuk a projekthez az alábbiakat:

- *Newtonsoft.Json* NuGet csomagot
- a *System.Runtime.Serialization* és a  *System.ComponentModel.DataAnnotations* .NET FW szerelvényeket függőségként
- egy osztályt `Api` néven

Indítsuk el a projektünket (a szerveroldalra lesz most szükség) és az NSwag Studio-t és adjuk meg az NSwag Studio-ban az alábbi beállításokat:

- Input rész (bal oldal): válasszuk a *Swagger Specification* fület és adjuk meg a swagger leírónk címét. Nyomjuk meg a **Create local Copy** gombot.
- Input rész (bal oldal) - Runtime: Default
- Output rész (jobb oldal) - jelöljük be a CSharp Client jelölőt
- Output rész (jobb oldal) - CSharp Client fül - Settings alfül: fölül a *Namespace* mezőben adjunk meg egy névteret, pl. *WebApiLabor.Client.Api*

![NSwag Studio beállítások](images/aspnetcorerest-nswagstudio.png)

Jobb oldalt alul a *Generate Ouputs* gombbal generáltathatjuk a kliensoldali kódot.

A generált kóddal írjuk felül az *Api.cs* tartalmát (ehhez le kell állítani a futtatást). Ezután a projektnek fordulnia kell. Írjunk meg a *Program.cs*-ben a `GetProduct` új változatát:

```csharp
public static async Task<Product> GetProduct2Async(int id)
{
    using (var httpClient = new HttpClient())
    {
        ProductsClient client= new ProductsClient(httpClient);
        return await client.GetAsync(id);
    }
}
```

Használjuk az új változatot a `Main` függvényben.

```csharp
static async Task Main(string[] args)
{
    //..
    //leanpub-start-insert
    //await GetProductAsync(Int32.Parse(id));
    var p = await GetProduct2Async(int.Parse(id));
    Console.WriteLine(p.Name);
    //leanpub-end-insert
    Console.ReadKey();
}
```

Próbáljuk ki, hogy megjelenik-e a kért termék neve.

T> Ez csak egy minimálpélda volt, az NSwag nagyon sok beállítással [rendelkezik](https://github.com/RicoSuter/NSwag/wiki).

## Hibakezelés

Eddig főleg csak a hibamentes ágakat (happy path) néztük. A REST konvenciók rendelkeznek arról is, hogy bizonyos hibahelyezetekben milyen HTTP választ illik adni, például ha a kérésben hivatkozott azonosító nem létezik - 404-es hiba a bevett eljárás. Státuszkódok szempontjából a korábban idézett oldal ad segítséget, a válasz törzsében a hibaüzenet szerkezete tekintetében az [RFC 7807](https://tools.ietf.org/html/rfc7807) ad iránymutatást az ún. *Problem Details* típusú válaszok bevezetésével. Az ASP.NET Core 2.1-es verzió óta támogatja a Problem Details válaszokat, és általában automatikusan ilyen válaszokat küld.

### 400 Bad Request

Kezdjük a kliens által küldött nem helyes adatokkal. Ez a hibakód nem összekeverendő a 415-tel, ahol az adat formátuma nem megfelelő (XML vagy JSON): ezt általában nem kell kézzel lekezeljük, mivel ezt az ASP.NET megteszi helyettünk. 400-zal olyan hibákat szoktunk lekezelni, ahol a küldött adat formátuma megfelelő, de valamilyen saját validációs logikának nem felel meg a kapott objektum pl.: egységár nem lehet negatív stb.

Itt használjuk fel a .NET ún. *Data Annotation* attribútumait, amiket a DTO-kon érvényesíthetünk, és az ASP.NET Core figyelembe vesz a művelet végrehajtása során. Vegyük fel a `Product` DTO osztályban néhány megkötést attribútumok formájában.

```csharp
//leanpub-start-insert
[Required(ErrorMessage = "Product name is required.", AllowEmptyStrings = false)]
//leanpub-end-insert
public string Name { get; set; }

//leanpub-start-insert
[Range(1, int.MaxValue, ErrorMessage = "Unit price must be higher than 0.")]
//leanpub-end-insert
public int UnitPrice { get; set; }
```

Próbáljuk ki a swagger felületen a **POST /api/Product** művelet meghívásával. Paraméterként kiindulhatunk a felület által adott minta JSON-ból, csak töröljük ki a navigációs property-ket és sértsük meg valamelyik (mindkét) fenti szabályt.

A válasz 400-as kód és valami hasonló, RFC 7807-nek megfelelő törzs lesz:

```javascript
{
  "errors": {
    "Name": [
      "Pruduct name is required."
    ]
  },
  "title": "One or more validation errors occurred.",
  "status": 400,
  "traceId": "0HLMC1KB0ODP6:00000004"
}
```

### 404 Not Found - kontroller szinten

Konvenció szerint 404-es hibát kellene adnunk, ha a keresett azonosítóval nem található erőforrás - esetünkben termék. Jelenleg a `ProductService` `EntityNotFoundException`-t dob, és amennyiben Development módban futtatjuk az alkalmazást, a cifra hibaoldal jelenik meg, amit a *DeveloperExceptionPage* middleware generál. Ha kivesszük a middleware-t (vagy nem Development módban indítjuk, de ekkor gondoskodnunk kell connection string-ről, ami eddig csak a Development konfigurációban volt beállítva), akkor 500-as hibát kapunk vissza.

W> A kezeletlen kivételek általában 500-as hibakód formájában kerülnek vissza a kliensre, mindenfajta egyéb információ nélkül. Ez a jobbik eset, ahhoz képest, ha a teljes kivételszöveg és stack trace is visszakerülne. Az átlagos felhasználók nem tudják értelmezni, viszont a támadó szándékúaknak értékes információt jelenthet, így ajánlott elkerülni, hogy a kivétel ilyen módon kijusson. Ez az elkerülés az úgynevezett *Exception Shielding* technika, és az ASP.NET Core alapértelmezetten alkalmazza.

Legegyszerűbb módszer a kontroller műveletben érvényesíteni a konvenciót:

```csharp
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    //leanpub-start-insert
    try
    {
    //leanpub-end-insert
        return _mapper.Map<Product>(_productService.GetProduct(id));
    }
    //leanpub-start-insert
    catch (EntityNotFoundException)
    {
        return NotFound();
    }
    //leanpub-start-insert
}
```

T> Alternatív megoldás, hogy a `ProductService` egy `null` értékkel jelezné, hogy nincs találat. Ezesetben a fenti kódban a `null` értékre kellene szűrni.

Próbáljuk ki, hogy 404-es státuszkódot kapunk-e, ha egy nem létező termékazonosítóval hívjuk a fenti műveletet.

Ha ProblemDetails-t is szeretnénk a 404-es kód mellé, akkor kézzel összerakhatjuk és visszaküldhetjük.

```csharp
catch (EntityNotFoundException)
{
    //leanpub-start-insert
    ProblemDetails details= new ProblemDetails
    {
        Title = "Invalid ID",
        Status = StatusCodes.Status404NotFound
    };
    return NotFound(details);
    //leanpub-end-insert
}
```

Így is próbáljuk ki.

### 404 Not Found - globális kivétel leképezéssel

A rendhagyó válaszok előállításánál előnyös lehet, ha az alacsonyabb rétegekből specifikus kivételeket dobunk, mert ezeket egy központi helyen szisztematikusan átalakíthatjuk konvenciónak megfelelő HTTP válaszokká. Ez a képesség egyelőre még nem érhető el beépítetten, egy közösségi fejlesztésű NuGet csomagot használunk fel.

Telepítsük fel a *Hellang.Middleware.ProblemDetails* csomagot az API projektbe.

```powershell
Install-Package Hellang.Middleware.ProblemDetails
```

Szokás szerint konfiguráljuk a `Startup.ConfigureServices`-ben:

```csharp
services.AddProblemDetails(options =>
{
    options.IncludeExceptionDetails = ctx =>false;
    options.Map<EntityNotFoundException>(ex =>
        new ProblemDetails{
            Title = "Invalid ID",
            Status = StatusCodes.Status404NotFound
    });
});
```

Illesszük a pipeline-ba a `Startup.Configure`-ban az MVC MW elé. Az eddigi hibakezelő MW-re már nincs szükség, kommentezzük ki :

```csharp
public void Configure(/*...*/)
{
    //leanpub-start-insert
    /*if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }*/
    //leanpub-end-insert

    app.UseSwagger();
    app.UseSwaggerUi3();

    //leanpub-start-insert
    app.UseProblemDetails();
    //leanpub-end-insert
    app.UseMvc();
}
```

Térjünk vissza a korábbi, nem kivétel-elkapós változatra:

```csharp
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    return _mapper.Map<Product>(_productService.GetProduct(id));
}
```

Próbáljuk ki: hasonlóan kell működjön, mint a kontroller szintű változat, de ez általánosabb, bármely műveletből `EntityNotFoundException` érkezik, azt kezeli, nem kell minden műveletben megírni a kezelő logikát.

### 500 Internal Server Error

A következő kiegészítéssel szimuláljunk egy nem várt hibát.

```csharp
[HttpGet("{id}", Name = "Get")]
public ActionResult<Product> Get(int id)
{
    //leanpub-start-insert
    if(id==0) throw new ArgumentException();
    //leanpub-end-insert
    return _mapper.Map<Product>(_productService.GetProduct(id));
}
```

Próbáljuk ki: az újonnan beállított MW a nem kezelt kivétel esetén is egy alapszintű Problem Details választ állít elő 500-as kóddal.

### 409 Conflict - konkurenciakezelés

Konfiguráljuk fel a `Product` entitást úgy, hogy az esetleges konkurenciahelyzeteket is felismerje a frissítés során. Jelöljünk ki egy kitüntetett mezőt (`RowVersion`), amit minden update műveletkor frissítünk, így ez az egész rekordra vonatkozó konkurenciatokenként is felfogható.

Ehhez vegyünk fel egy `byte[]`-t a `Product` entitás osztályba `RowVersion` néven.

```csharp
public class Product
{
    //...
    //leanpub-start-insert
    public byte[] RowVersion { get; set; }
    //leanpub-end-insert
}
```

Állítsuk be, hogy az EF kontextben (`OnModelCreating`), hogy minden update-nél frissítse ezt a mezőt és ez legyen a konkurencia token:

```csharp
modelBuilder.Entity<Product>()
    .Property(p => p.RowVersion)
    .ValueGeneratedOnAddOrUpdate()
    .IsConcurrencyToken();
```

A háttérben az EF az update során egy plusz feltételt csempész az SQL utasításba a SaveChanges során, mégpedig, hogy az adatbázisban lévő `RowVersion` mező adatbázisbeli értéke az ugyanaz-e mint, amit ő ismert (a kliens által). Ha ez a feltétel sérül, akkor konkurenciahelyzet áll fent, mivel valaki már megváltoztatta a DB-ben lévő értéket.

Migrálnunk kell mert megjelent egy új mező a `Product` táblánkban. Ne felejtsük el a szokásos módon beállítani az indítandó és a kontextet tartalmazó projekteket!

```powershell
Add-Migration ProductRowVersion -StartupProject WebApiLabor.Api
Update-Database -StartupProject WebApiLabor.Api
```

Még a Product DTO osztályba is fel kell vegyük a `RowVersion` tulajdonságot és legyen ez is kötelező.

```csharp
public class Product
{
    //...
    //leanpub-start-insert
    [Required(ErrorMessage = "RowVersion is required")]
    public byte[] RowVersion { get; set; }
    //leanpub-end-insert
}
```

Konkurenciahelyzet esetén a 409-es hibakóddal szokás visszatérni, illetve PUT művelet során a válasz azt is tartalmazhatja, hogy melyek voltak az ütköző mezők. Az ütközés feloldása tipikusan nem feladatunk ilyenkor. Készítsünk egy saját ProblemDetails leszármazottat. Hozzunk létre egy új osztály `ConcurrencyProblemDetails` néven, az alábbi implementációval:

```csharp
/*kóddarabka*/
public class Conflict
{
    public object CurrentValue { get; set; }
    public object SentValue { get; set; }
}

public class ConcurrencyProblemDetails : StatusCodeProblemDetails
{
    public Dictionary<string, Conflict> Conflicts { get; }

    public ConcurrencyProblemDetails(DbUpdateConcurrencyException ex) :
        base(StatusCodes.Status409Conflict)
    {
        Conflicts = new Dictionary<string, Conflict>();
        var entry = ex.Entries[0];
        var props = entry.Properties
            .Where(p => !p.Metadata.IsConcurrencyToken).ToArray();
        var currentValues = props.ToDictionary(
            p => p.Metadata.Name, p => p.CurrentValue);

        //with DB values
        entry.Reload();

        foreach (var property in props)
        {
            if (!currentValues[property.Metadata.Name].
                Equals(property.CurrentValue))
            {
                Conflicts[property.Metadata.Name] = new Conflict
                {
                    CurrentValue = property.CurrentValue,
                    SentValue = currentValues[property.Metadata.Name]
                };
            }
        }
    }
}
```

A fenti megvalósítás összeszedi az egyes property-khez (a `Dictionary` kulcsa) a jelenlegi (`CurrentValue`) és a kliens által küldött (`SentValue`) értéket.

```csharp
services.AddProblemDetails(options =>
{
    //..
    //leanpub-start-insert
    options.Map<DbUpdateConcurrencyException>(
        ex => new ConcurrencyProblemDetails(ex));
    //leanpub-end-insert
});
```

Próbáljuk ki!

- Indítsunk el a swagger oldalt két példányban.
- Hajtsunk végre egy *GET api/Product/1* kérést.
- A kapott eredményt használjuk fel a PUT művelet elkészítéséhez **mindkét oldalpéldányon**.
- Az egyik oldalon írjuk át a `name` tulajdonságot, de még ne indítsuk el a kérést!
- A másik oldalon
  - írjuk át az árat egy új értékre, de ügyeljünk arra, hogy a nevet a régi értéken hagyjuk.
  - indítsuk is el a kérést! Figyeljük meg, hogy a válasz sikeres (204), ár és a `rowVersion` megváltozott.
- Az előző swagger oldalon indítsuk el a név frissítését. (Emlékezzünk, hogy már más az adatbázisban lévő entitás rowVersion értéke, így konfliktusra fogunk futni.)
  - Az eredmény 409-es státuszkód és a Problem Details-ben láthatjuk a konfliktust okozó értékeket

![Konkurencia - bemenetek](images/aspnetcorerest-conflictinputs.png)

![Konkurencia - válasz](images/aspnetcorerest-conflictresult.png)
