# C# alapok III.

## Tuple nyelvi szinten, lokális függvények

Készítsünk Fibonacci számsor kiszámolására alkalmas függvényt, ahol használjunk ki az alábbi két új nyelvi elemet. Természetesen nagyon sok féleképpen meg lehetne valósítani ezt a metódust, de most kifejezetten a Tuple-ök nyelvi támogatását és lokális függvényeket szeretnénk demonstrálni.

- Lokális függvények: ezek a függvények csak adott metódusban láthatók. Két esetben érdemes őket használni: ha nem szeretnénk „szennyezni” a környező osztályt különféle privát segédmetódusokkal, vagy ha egy mélyebb, komplexebb hívási láncban nem szeretnénk a paramétereket folyamatosan „továbbpasszolni”, ugyanis ezek a metódusok elérik a külső scope-on található változókat is (ebben az esetben például az x-et).
- Tuple típus: a tuple (ennes) több elem összefogása, ami gyors, nyelvi szinten támogatott adattovábbítást tesz lehetővé (gyakorlatilag inline, nevesítetlen struktúratípust hozunk így létre). Publikus API-kon, függvényeken nem érdemes használni, viszont privát, internal, package-szintű használatnál sebességnövekedést és API tisztulást érhetünk vele el. Az eredeti Tuple típushoz hasonlóan működnek, ellenben az Item1, Item2… tulajdonságok opcionálisan nevesítve is elérhetők benne. A Tuple-ökre a funkcionális nyelvek hatása miatt az utóbbi időben nagy hangsúlyt fektettek, így rekord-jellegűen kezelhetők, létezik például elem dekonstruálás

```csharp
public static long Fibonacci(long x)
{
    (long Current, long Previous) Fib(long i) // Nevesített Tuple visszatérés
    {
        if (i == 0) return (1, 0);
        var (curr, prev) = Fib(i - 1); // Az eredmény eltárolása egy Tuple változóban
        Thread.Sleep(100); // Lassú művelet szimulációja
        return (curr + prev, curr);
    }

    return x < 0
        ? throw new ArgumentException("Less negativity please!", nameof(x))
        : Fib(x).Current;
}
```

## Dispose minta

A Dispose minta az erőforrás-felszabadítás megfelelő megvalósításához készült. Hasonló elv mentén üzemel, mint a destruktor, viszont a minta nem feltétlenül kötött az objektum életciklusának elejéhez és végéhez. Amennyiben egy objektum megvalósítja az IDisposable interfészt, van Dispose metódusa. A metódus meghívásával az objektum által használt, nem a keretrendszer által menedzselt erőforrásokat szabadítjuk fel. Nem csak memóriafoglalásra kell gondolni, hanem lehetnek nyitott fájlrendszeri handle-ök, adatkapcsolatok, stream-ek, vagy üzleti erőforrások, tranzakciók.

Mérjük meg az első 50 Fibonacci szám kiszámítását (a mesterséges késleltetéssel):

```csharp
static void Main(string[] args)
{
    var sw = Stopwatch.StartNew();
    foreach (var n in Enumerable.Range(1, 50))
    {
        Console.WriteLine($"{n}: {Fibonacci(n)}");
    }
    sw.Stop();
    Console.WriteLine($"Elapsed: {sw.ElapsedMilliseconds}");
    Console.ReadKey();
}
```

Ez így jó, működik, viszont nem újrahasznosítható ez az időmérési mechanizmus.

Készítsünk egy saját időmérő osztályt `StopwatchWrapper` méven, ami a `Stopwatch` használatát egyszerűsíti a Dispose mintán keresztül.

```csharp
public class StopwatchWrapper : IDisposable
{
    public Stopwatch Stopwatch { get; } // using System.Diagnostics

    public string Title { get; }

    public StopwatchWrapper(string title = null)
    {
        Title = title ?? Guid.NewGuid().ToString();
        Console.WriteLine($"Task {title} starting at {DateTime.Now}.");
        Stopwatch = Stopwatch.StartNew();
    }
}
```

Ha kérjük a villanykörte segítségét az `IDisposable`-ön, akkor 2x2 lehetőségünk van: megvalósítjuk az interfészt implicit vagy explicit, illetve megvalósítjuk-e az interfészt a Dispose mintát alkalmazva. Valósítsuk meg implicit a Dispose mintát!

![Dispose minta implementálása IntelliSense segítségével](images/csharp4-dispose.png)

Fussuk át a kódot, ami szépen kommentezett. A pattern lényege, hogy nem menedzselt kód esetén az erőforrásokat szükséges felszabadítanunk, amit a Dispose metódusokban, ill. menedzselt kód esetén adott helyen érdemes ezt elvégeznünk. Készítsük el az időmérő mechanizumust!

```csharp
protected virtual void Dispose(bool disposing)
{
    if (!disposedValue)
    {
        if (disposing)
        {
            /*leanpub-start-insert*/
            Stopwatch.Stop();
            Console.WriteLine(
                $"Task {Title} completed in { Stopwatch.ElapsedMilliseconds} ms at { DateTime.Now}");
            /*leanpub-end-insert*/
        }
        disposedValue = true;
    }
}
```

Az `IDisposable` interfészt megvalósító elemekkel használhatjuk a `using` konstrukciót:

```csharp
static void Main(string[] args)
{
    /*leanpub-start-insert*/
    using (new StopwatchWrapper("Fib 1-50"))
    {
        foreach (var n in Enumerable.Range(1, 50))
        {
            Console.WriteLine($"{n}: {Fibonacci(n)}");
        }
    }
    /*leanpub-end-insert*/
    Console.ReadKey();
}
```

Tehát a using használatával a blokk elejét és végét tudjuk kezelni. Gyakorlatilag egy `try-finally`-val ekvivalens a minta, a `finally`-ben meghívódik a `Dispose` metódus.

Vegyíthetjük ezt a változó kiemelésével is, de előbb készítsünk egy segédfüggvényt a `StopwatchWrapper`-be:

```csharp
public void Snapshot(string text) =>
    Console.WriteLine($"Task {Title} snapshot {text}: {Stopwatch.ElapsedMilliseconds} ms");
```

```csharp
using (
     /*leanpub-start-insert*/
    var sw =
     /*leanpub-end-insert*/
        new StopwatchWrapper("Fib 0-50"))
{
    foreach (var n in Enumerable.Range(1, 50))
    {
        /*leanpub-start-insert*/
        sw.Snapshot(n.ToString());
        /*leanpub-end-insert*/
        Console.WriteLine($"{n}: {Fibonacci(n)}");
    }
}
```

## Aszinkron működés

Töltsünk le egy HTML oldalt, és ezen a problémán keresztül bemutatjuk az aszinkron programozási modellt. A HttpClient működésének a részletesebb ismertetése most nem téma, csak a legalapabb funkciókat fogjuk használni.

A fő gond a hosszan futó műveletek blokkolhatják a fő/UI/aktuális szál futását, Ez kliens alkalmazások esetében úgy jelentkezik, hogy nem lesz a alkalmazásunk reszponzív a felhasználói inputok-ra, szerveralkalmazások esetében pedig az adott kérést kiszolgáló szál feleslegesen blokkolódik, amikor esetleg mással is tudna foglalkozni.

Ötlet a hosszan tartó műveleteket végezzük aszinkron módon, egy másik szálon, és ha az befejeződött az eredményről valamilyen módon értesüljünk. Az előadáson bemutatásra kerültek a különböző modellek: Asynchronous Programming Model (APM), Event-based Asynchronous Pattern (EAP), Task-based Asynchronous Pattern (TAP).

A TAP-ra már C# nyelvi támogatást is kapunk az `async`/`await` kulcsszavakon keresztül.
Vegyünk fel egy új metódust és hívjuk meg a main metódusban. A megírt metódus írása során hivatkozzuk be a Systen.Net.Http névteret. A kód semmi más nem csinál, csak elindít aszinkron módon egy HTTP GET kérést a megadott url-re, illetve a válasz tartalmát is aszinkron módon kiolvassa és kiírja a konzolra.

Vegyünk fel egy új metódust és hívjuk meg a `Main` metódusban. A megírt metódus írása során hivatkozzuk be a `Systen.Net.Http` névteret. A kód semmi mást nem csinál, csak elindít aszinkron módon egy HTTP GET kérést a megadott url-re, illetve a válasz tartalmát is aszinkron módon kiolvassa és kiírja a konzolra.

```csharp
static void Main(string[] args)
{
    LoadWebPageAsync();

    Console.WriteLine("Ez a vége");
    Console.ReadKey();
}

public static async void LoadWebPageAsync()
{
    using (var client = new HttpClient())
    {
        var response = await client.GetAsync(new Uri("http://www.bing.com"));
        Console.WriteLine(response.StatusCode.ToString());

        var content = await response.Content.ReadAsStringAsync();
        Console.WriteLine(content.Take(1000).ToArray());
    }
}
```

**await:** Mindig egy `Task` awaitelhető (vagy taszk szerű dolog: vagyis van neki GetAwaiter metódusa, ami meghatározott metódusokkal rendelkező objektummal tér vissza)! Akár létre is hozhatunk egy `Task`-ot, amit egy lokális változóban tárolunk, akkor azt is tudjuk `await`-elni.

**async:** ha await-elni akarunk, akkor muszáj `async`-nak lennie a tartalmazó metódusnak, mert ilyenkor építi fel a fordító az aszinkron végrehajtáshoz szükséges állapotgépet.

Debuggoljuk ki! Nézzük meg melyik rész milyen szálon fut le. Azt is nézzük meg milyen sorrendben. A `LoadWebPageAsync` utáni rész előbb fog lefutni, mint az első await utáni rész.

Figyeljük meg, hogy az „Ez a vége” szöveg hamarabb kiíródik, mit a HTML oldal letöltése.

Próbáljuk ki a `Console.ReadKey` nélkül is, ilyenkor jó eséllyel hamarabb leáll a process, minthogy a `Task` befejeződne. Az ilyen fire-and-forget típusú hívásoknál nem figyel arra senki, hogy itt még valami háttérművelet folyik.

### Az oldalletöltés bevárása

Módosítsuk úgy a kódot, hogy a `LoadWebPageAsync` utáni rész várja meg a letöltés befejeződését. Ez akkor jó például, ha a letöltés után valamit még szeretnék elvégezni a hívó függvényben.

T> Az async void általában nem jó, mert nem lehet bevárni a végét. Az `async Task` máris jobb a bevárhatóság és a hibakezelés miatt, és alig kell módosítani a kódot. Kivétel, amikor valamiért szükséges a `void` pl. esemény vagy interfész előírja.

Módosítsuk a `LoadWebPageAsync` fejlécét, hogy taszkot adjon vissza:

```csharp
public static async Task LoadWebPageAsync()
```

Várjuk be az szinkron művelet végét a Main függvényben. Ehhez viszont a Main függvénynek is async-nak kell lennie. Ez GUI-s és szerver alkalmazásoknál nem gond, de a konzol alkalmazásokat csak a C# 7.1 óta támogatott. Ehhez állítsuk át a fordító verzióját: Project Properties → Build → Advanced → Language version → C# 7.1 (minimum).

Így már lehet aszinkron a Main metódus is, így lehet benne await-elni:

```csharp
static async Task Main(string[] args)
{
    await LoadWebPageAsync();

    Console.WriteLine("Ez a vége");
    Console.ReadKey();
}
```

Figyeljük meg, hogy így már az „Ez a vége” felirat már a letöltés után jelenik meg.

T> Az `async Main` háttere: a fordító egy saját (nem `async`-os) `Main`-t generál, ez lesz az igazi belépési pont. Annyit csinál, hogy áthív és bevárja a mi `Main`-ünket.

### Háttérművelet eredményének visszaadása

Alakítsuk át, hogy a weboldal tartalmának kiíratása a `Main`-ben történjen, és a `LoadWebPageAsync` csak adja vissza a tartalmat `string`-ként. Ehhez módosítsuk a visszatérési értéket `Task<string>`-re, így az `await` már eredménnyel fog tudni visszatérni.

```csharp
static async Task Main(string[] args)
{
    /*leanpub-start-insert*/
    var content = await LoadWebPageAsync();
    Console.WriteLine(content);
    /*leanpub-end-insert*/

    Console.WriteLine("Ez a vége");
    Console.ReadKey();
}

public static async Task<string> LoadWebPageAsync()
{
    using (var client = new HttpClient())
    {
        var response = await client.GetAsync(new Uri("http://www.bing.com"));
        Console.WriteLine(response.StatusCode.ToString());

        var content = await response.Content.ReadAsStringAsync();
        /*leanpub-start-insert*/
        return new string(content.Take(1000).ToArray());
        /*leanpub-start-insert*/
    }
}
```

A `return` valójában ezen `Task` eredményét állítja be `async` metódusok esetében, és nem egy nemgenerikus `Task` objektummal kell visszatérjünk.

## Bejárási problémák

Enumerátorok használata esetén két alapvető problémába ütközünk: az egyik a mögöttes kollekció módosulása bejárás során, a másik pedig a késleltetett kiértékelésből adódó mellékhatások kezelése.

### Kollekció módosulása bejárása során

Szűrjünk le egy szám-szám szótárat csak azokra az elemekre, amik megfelelnek egy feltételnek, és ezeket távolítsuk el a szótárból!

```csharp
var numbers = new Dictionary<int, int>
{
    [1] = 5,
    [2] = 4,
    [3] = 3,
    [4] = 2,
    [5] = 1
};

foreach (var p in numbers)
{
    if (p.Value % 2 == 0)
    {
        numbers.Remove(p.Key);
    }
}
```

Kivételt kapunk, mi a probléma? A kollekciót bejárás közben szerettük volna módosítani, viszont ez könnyen nem várt működést (túlcímzést, nemdeterminisztikus bejárást) tenne lehetővé, ezért kivételt kapunk. Oldjuk meg a problémát: nem módosíthatjuk a forrás objektumot bejárás közben, tehát ne azt a kollekciót járjuk be, másoljuk le!

```csharp
foreach (var p in numbers.ToList())
```

Ez megoldja a problémát, sikerül eltávolítani az elemeket a kollekcióból. De miért? A `ToList` `IEnumerable` bővítő, tehát bejárhatja a kollekciót… ezután pedig egy másik `List<>` objektumban tárolja az elemeket.

### Azonnali és késleltetett kiértékelés

Amennyiben egy metódus generátor (`IEnumerable` vagy `IEnumerable<T>` visszatérési értékű), az egyes elemeken történő iteráció a generátorok egymásba ágyazását jelenti, azaz az egyes generátorokban a yield return által visszaadott értéket fogja az enumerátor `MoveNext` metódusa visszaadni. Amíg az `IEnumerable`-re van referenciánk, és nem járjuk azt közvetlenül be, addig *késleltetett kiértékelésről* beszélünk.

```csharp
var i = 0;
foreach (var n in numbers
                    .Where(p => p.Value > 2)
                    .Select(p => new { p, x = ++i }))
{
    Console.WriteLine($"{n} - {i}");
}

Console.WriteLine();

i = 0;
foreach (var n in numbers
                    .Where(p => p.Value > 2)
                    .Select(p => new { p, x = ++i })
                    .ToList())
{
    Console.WriteLine($"{n} - {i}");
}
```

A `ToList` hívásunk először bejárja az iterátort és visszaad egy listát, amelybe összegyűjti az `IEnumerable` elemeit. Ezért az `i` változónk a második esetben nem együtt inkrementálódik a bejárással, mert az kétszer történik meg. Az első bejáráskor (a `ToList` hívásakor) inkerementálódik az `i` értéke, másodjára pedig már csak bejárjuk a kapott listát. Eddigre az `i` értéke már meg van növelve.

Ezzel a megközelítéssel futásidőben is állíthatunk össze egy időben változó lekérdezést, amit majd egyszer, a későbbiekben fogunk bejárni (pl. sorosításkor).

## Enumerátorok

Készítsünk egy olyan enumerátort, ami véletlen sorrendben adja vissza az elemeket a bejárás során!

```csharp
public class RandomOrderedList<T> : IEnumerable<T>
{
    public RandomOrderedList(IList<T> source) => Source = source;
    private IList<T> Source { get; }
    public IEnumerator<T> GetEnumerator() => new RandomEnumerator<T>(Source);
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

public class RandomEnumerator<T> : IEnumerator<T>
{
    private IList<T> Source { get; }
    private int[] indexes;
    private int currentIndex;
    public RandomEnumerator(IList<T> source)
    {
        Source = source;
        Reset();
    }
    public T Current => Source[indexes[currentIndex]];
    object IEnumerator.Current => Current;
    public void Dispose() { }
    public bool MoveNext() => ++currentIndex < Source.Count;
    public void Reset() => indexes = Enumerable.Range(currentIndex = 0, Source.Count)
                                               .OrderBy(i => Guid.NewGuid()).ToArray();
}
```

Így használhatjuk:

```csharp
foreach (var elem in new RandomOrderedList<int>(Enumerable.Range(0, 100).ToList()))
    Console.WriteLine(elem);
```
